<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The GAME - P2P Card Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="cards.js"></script>
</head>
<body>
    <div id="root"></div>

    <script>
        const { useState, useEffect, useRef } = React;

        // Import card data
        const { GAME_CARDS, getAllMainDeckCards, shuffleDeck } = window;

        function App() {
            const [logs, setLogs] = useState([]);
            const [status, setStatus] = useState('initializing');
            const [isPlayer1, setIsPlayer1] = useState(false);
            const [gameLink, setGameLink] = useState('');
            const [connected, setConnected] = useState(false);

            // Game state
            const [gameState, setGameState] = useState(null);
            const [selectedCards, setSelectedCards] = useState([]);
            const [winner, setWinner] = useState(null);

            const peerRef = useRef(null);
            const connRef = useRef(null);
            const qrRef = useRef(null);

            const addLog = (message) => {
                const time = new Date().toLocaleTimeString();
                setLogs(prev => [...prev, { time, message }]);
            };

            // Initialize game state
            const initializeGame = (asPlayer1) => {
                const mainDeck = shuffleDeck(getAllMainDeckCards());
                const equipmentDeck = shuffleDeck([...GAME_CARDS.equipmentDeck]);
                const pleasureDeck = shuffleDeck([...GAME_CARDS.pleasureDeck]);

                const state = {
                    mainDeck,
                    equipmentDeck,
                    pleasureDeck,
                    player1: {
                        hand: mainDeck.splice(0, 5),
                        points: 0,
                    },
                    player2: {
                        hand: mainDeck.splice(0, 5),
                        pleasureCards: [],
                    },
                    queue: [],
                    currentTurn: 1, // 1 or 2
                    discardPile: [],
                };

                return state;
            };

            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const peerId = urlParams.get('peer');

                if (!peerId) {
                    // Player 1: Create peer and wait for connection
                    setIsPlayer1(true);
                    addLog('Initializing as Player 1...');

                    const peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', (id) => {
                        addLog(`Peer created with ID: ${id}`);
                        const link = `${window.location.origin}${window.location.pathname}?peer=${id}`;
                        setGameLink(link);
                        setStatus('waiting');
                        addLog('Waiting for Player 2 to connect...');
                        addLog('Share the link below to invite them!');

                        // Generate QR code
                        setTimeout(() => {
                            if (qrRef.current && window.QRCode) {
                                qrRef.current.innerHTML = '';
                                new QRCode(qrRef.current, {
                                    text: link,
                                    width: 200,
                                    height: 200,
                                    colorDark: '#000000',
                                    colorLight: '#ffffff',
                                    correctLevel: QRCode.CorrectLevel.M
                                });
                            }
                        }, 100);
                    });

                    peer.on('connection', (conn) => {
                        addLog('Player 2 is connecting...');
                        connRef.current = conn;
                        setupConnection(conn, true);
                    });

                    peer.on('error', (err) => {
                        addLog(`Error: ${err.message}`);
                    });

                } else {
                    // Player 2: Connect to Player 1
                    setIsPlayer1(false);
                    addLog('Initializing as Player 2...');
                    setStatus('connecting');

                    const peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', () => {
                        addLog('Peer initialized');
                        addLog(`Connecting to Player 1 (ID: ${peerId})...`);

                        const conn = peer.connect(peerId, {
                            reliable: true
                        });

                        connRef.current = conn;
                        setupConnection(conn, false);
                    });

                    peer.on('error', (err) => {
                        addLog(`Error: ${err.message}`);
                    });
                }

                return () => {
                    if (connRef.current) {
                        connRef.current.close();
                    }
                    if (peerRef.current) {
                        peerRef.current.destroy();
                    }
                };
            }, []);

            const setupConnection = (conn, asPlayer1) => {
                conn.on('open', () => {
                    addLog('Connection opened!');
                    addLog('ICE route finding complete');
                    setStatus('connected');
                    setConnected(true);

                    if (asPlayer1) {
                        // Player 1 initializes the game
                        const initialState = initializeGame(true);
                        setGameState(initialState);
                        sendGameState(initialState);
                        addLog('Game initialized! Player 1 starts.');
                    } else {
                        addLog('Waiting for game initialization...');
                    }
                });

                conn.on('data', (data) => {
                    handleMessage(data);
                });

                conn.on('close', () => {
                    addLog('Connection closed');
                    setConnected(false);
                    setStatus('disconnected');
                });

                conn.on('error', (err) => {
                    addLog(`Connection error: ${err.message}`);
                });
            };

            const sendGameState = (state) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'gameState',
                        state: state
                    });
                }
            };

            const sendAction = (action) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'action',
                        action: action
                    });
                }
            };

            const handleMessage = (data) => {
                if (data.type === 'gameState') {
                    setGameState(data.state);
                    addLog('Game state updated');
                } else if (data.type === 'action') {
                    processAction(data.action);
                } else if (data.type === 'winner') {
                    setWinner(data.winner === 'opponent' ? 'opponent' : 'me');
                    addLog(data.winner === 'opponent' ? 'Opponent won!' : 'You won!');
                }
            };

            const processAction = (action) => {
                // Process opponent's action and update game state
                setGameState(prevState => {
                    const newState = { ...prevState };

                    switch (action.type) {
                        case 'playSet':
                            // Add set to queue
                            newState.queue.push(action.set);
                            // Update player stats
                            if (action.player === 1) {
                                newState.player1.points += 1;
                            }
                            // Switch turn
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent played a set`);
                            break;

                        case 'discard':
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent discarded a card`);
                            break;

                        case 'drawEquipment':
                            addLog(`Opponent drew equipment`);
                            break;

                        case 'drawPleasure':
                            addLog(`Opponent drew a pleasure card`);
                            break;
                    }

                    return newState;
                });
            };

            const handleCardClick = (card) => {
                if (!isMyTurn()) return;

                setSelectedCards(prev => {
                    const isSelected = prev.find(c => c.id === card.id);
                    if (isSelected) {
                        return prev.filter(c => c.id !== card.id);
                    } else {
                        return [...prev, card];
                    }
                });
            };

            const isMyTurn = () => {
                if (!gameState) return false;
                return (isPlayer1 && gameState.currentTurn === 1) ||
                       (!isPlayer1 && gameState.currentTurn === 2);
            };

            const canPlaySet = () => {
                if (selectedCards.length !== 3) return false;
                const hasPosition = selectedCards.some(c => c.type === 'position');
                const hasIntensity = selectedCards.some(c => c.type === 'intensity');
                const hasTime = selectedCards.some(c => c.type === 'time');
                return hasPosition && hasIntensity && hasTime;
            };

            const handleDrawCard = () => {
                if (!isMyTurn() || !gameState) return;

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    if (newState.mainDeck.length > 0) {
                        const drawnCard = newState.mainDeck.shift();
                        newState[playerKey].hand.push(drawnCard);
                        addLog(`Drew: ${drawnCard.name}`);
                    }

                    // Send state after update
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });
            };

            const handlePlaySet = () => {
                if (!canPlaySet() || !gameState) return;

                const position = selectedCards.find(c => c.type === 'position');
                const intensity = selectedCards.find(c => c.type === 'intensity');
                const time = selectedCards.find(c => c.type === 'time');

                const set = {
                    position,
                    intensity,
                    time,
                    equipment: []
                };

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove cards from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => !selectedCards.find(sc => sc.id === c.id)
                    );

                    // Add to queue
                    newState.queue.push(set);

                    // Update player stats
                    if (isPlayer1) {
                        newState.player1.points += 1;
                    } else {
                        // Player 2 draws pleasure card
                        if (newState.pleasureDeck.length > 0) {
                            const pleasureCard = newState.pleasureDeck.shift();
                            newState.player2.pleasureCards.push(pleasureCard);
                            addLog(`Drew pleasure: ${pleasureCard.name}`);
                        }
                    }

                    // Check win conditions
                    let hasWon = false;
                    if (newState.queue.length >= 5 && isPlayer1) {
                        hasWon = true;
                    } else if (newState.player2.pleasureCards.length >= 5 && !isPlayer1) {
                        hasWon = true;
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    addLog(`Played set: ${position.name} + ${intensity.name} + ${time.name}`);

                    // Notify about win
                    if (hasWon) {
                        setWinner('me');
                        setTimeout(() => {
                            if (connRef.current && connRef.current.open) {
                                connRef.current.send({
                                    type: 'winner',
                                    winner: 'opponent'
                                });
                            }
                        }, 100);
                    }

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'playSet',
                    player: isPlayer1 ? 1 : 2,
                    set
                };
                sendAction(action);

                // Use setTimeout to ensure state is updated before sending
                setTimeout(() => {
                    if (connRef.current && connRef.current.open && gameState) {
                        sendGameState(gameState);
                    }
                }, 50);
            };

            const handleDiscard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || !gameState) return;

                const discardedCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== discardedCard.id
                    );

                    // Add to discard pile
                    newState.discardPile.push(discardedCard);

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    addLog(`Discarded: ${discardedCard.name}`);

                    // Send updated state
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'discard'
                };
                sendAction(action);
            };

            const handleDrawEquipment = () => {
                if (!isPlayer1 || !isMyTurn() || !gameState || gameState.player1.points < 1) return;

                setGameState(prev => {
                    const newState = { ...prev };

                    if (newState.equipmentDeck.length > 0 && newState.queue.length > 0) {
                        const equipment = newState.equipmentDeck.shift();
                        newState.queue[newState.queue.length - 1].equipment.push(equipment);
                        newState.player1.points -= 1;
                        addLog(`Added equipment: ${equipment.name}`);

                        // Send updated state
                        setTimeout(() => {
                            sendGameState(newState);
                        }, 50);
                    }

                    return newState;
                });

                const action = {
                    type: 'drawEquipment'
                };
                sendAction(action);
            };

            const copyLink = async () => {
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(gameLink);
                        addLog('Link copied to clipboard!');
                    } else {
                        const textarea = document.createElement('textarea');
                        textarea.value = gameLink;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        addLog('Link copied to clipboard!');
                    }
                } catch (err) {
                    addLog('Failed to copy link');
                }
            };

            const shareLink = async () => {
                if (navigator.share) {
                    try {
                        await navigator.share({
                            title: 'The GAME',
                            text: 'Join me in a card game!',
                            url: gameLink
                        });
                        addLog('Link shared!');
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            addLog('Share failed, use copy instead');
                        }
                    }
                } else {
                    copyLink();
                }
            };

            const myHand = gameState && (isPlayer1 ? gameState.player1.hand : gameState.player2.hand);
            const myStats = gameState && (isPlayer1 ? gameState.player1 : gameState.player2);

            return React.createElement('div', { className: 'container' },
                React.createElement('h1', null, 'ğŸ´ The GAME'),

                React.createElement('div', {
                    className: `status ${status === 'waiting' ? 'waiting' : status === 'connecting' ? 'connecting' : status === 'connected' ? 'connected' : ''}`
                },
                    status === 'waiting' ? 'â³ Waiting for Player 2...' :
                    status === 'connecting' ? 'ğŸ”„ Connecting...' :
                    status === 'connected' ? 'âœ… Connected!' : 'ğŸ”§ Initializing...'
                ),

                React.createElement('div', { className: 'log-container' },
                    logs.map((log, i) =>
                        React.createElement('div', { className: 'log-entry', key: i },
                            React.createElement('span', { className: 'log-time' }, log.time),
                            React.createElement('span', null, log.message)
                        )
                    )
                ),

                !connected && isPlayer1 && gameLink && React.createElement('div', null,
                    React.createElement('div', { className: 'instructions' },
                        React.createElement('strong', null, 'ğŸ“‹ Instructions:'),
                        React.createElement('ol', null,
                            React.createElement('li', null, 'Scan the QR code with your phone, OR'),
                            React.createElement('li', null, 'Copy/share the link below'),
                            React.createElement('li', null, 'Send it to a friend'),
                            React.createElement('li', null, 'Wait for them to open it'),
                            React.createElement('li', null, 'Connection will establish automatically!')
                        )
                    ),
                    React.createElement('div', { className: 'qr-container' },
                        React.createElement('div', {
                            className: 'qr-code',
                            ref: qrRef
                        }),
                        React.createElement('div', { className: 'qr-label' }, 'ğŸ“± Scan to join on mobile')
                    ),
                    React.createElement('div', { className: 'link-display' }, gameLink),
                    React.createElement('div', { className: 'button-group' },
                        React.createElement('button', {
                            className: 'btn-primary',
                            onClick: copyLink
                        }, 'ğŸ“‹ Copy Link'),
                        React.createElement('button', {
                            className: 'btn-secondary',
                            onClick: shareLink
                        }, 'ğŸ“¤ Share Link')
                    )
                ),

                !connected && !isPlayer1 && React.createElement('div', { className: 'instructions' },
                    React.createElement('strong', null, 'ğŸ”— Connecting to Player 1...'),
                    React.createElement('p', { style: { marginTop: '12px' } },
                        'This may take 5-10 seconds while finding the best route...'
                    )
                ),

                connected && gameState && React.createElement('div', { className: 'game-container' },
                    winner && React.createElement('div', {
                        className: `winner-banner ${winner === 'me' ? 'win' : 'lose'}`
                    },
                        winner === 'me' ? 'ğŸ‰ You Won!' : 'ğŸ˜” You Lost!'
                    ),

                    React.createElement('div', { className: 'game-info' },
                        React.createElement('div', { className: 'player-info' },
                            React.createElement('div', { className: 'player-role' },
                                isPlayer1 ? 'ğŸ‘¤ Player 1' : 'ğŸ‘¤ Player 2'
                            ),
                            React.createElement('div', {
                                className: isMyTurn() ? 'turn-indicator' : 'turn-indicator not-your-turn'
                            },
                                isMyTurn() ? 'âœ“ Your Turn' : 'â³ Opponent\'s Turn'
                            )
                        ),
                        React.createElement('div', { className: 'player-stats' },
                            isPlayer1 && React.createElement('div', { className: 'stat' },
                                React.createElement('div', { className: 'stat-label' }, 'Points'),
                                React.createElement('div', { className: 'stat-value' }, myStats.points || 0)
                            ),
                            !isPlayer1 && React.createElement('div', { className: 'stat' },
                                React.createElement('div', { className: 'stat-label' }, 'Pleasure Cards'),
                                React.createElement('div', { className: 'stat-value' }, myStats.pleasureCards.length)
                            ),
                            React.createElement('div', { className: 'stat' },
                                React.createElement('div', { className: 'stat-label' }, 'Hand'),
                                React.createElement('div', { className: 'stat-value' }, myHand.length)
                            )
                        )
                    ),

                    React.createElement('div', { className: 'queue-section' },
                        React.createElement('div', { className: 'queue-header' },
                            `ğŸ”¥ Queue (${gameState.queue.length}/5)`
                        ),
                        gameState.queue.length === 0 && React.createElement('div', {
                            style: { color: '#92400e', fontStyle: 'italic' }
                        }, 'No punishments queued yet'),
                        React.createElement('div', { className: 'queue-items' },
                            gameState.queue.map((item, idx) =>
                                React.createElement('div', { className: 'queue-item', key: idx },
                                    React.createElement('div', { className: 'queue-set' },
                                        React.createElement('span', { className: 'mini-card position' }, item.position.name),
                                        React.createElement('span', { className: 'mini-card intensity' }, item.intensity.name),
                                        React.createElement('span', { className: 'mini-card time' }, item.time.name)
                                    ),
                                    item.equipment && item.equipment.length > 0 &&
                                    React.createElement('div', { className: 'queue-equipment' },
                                        item.equipment.map((eq, eqIdx) =>
                                            React.createElement('span', { className: 'equipment-tag', key: eqIdx }, eq.name)
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    !isPlayer1 && myStats.pleasureCards.length > 0 && React.createElement('div', { className: 'hand-section', style: { background: '#fce7f3', border: '2px solid #ec4899' } },
                        React.createElement('div', { className: 'hand-header', style: { color: '#831843' } }, 'ğŸ’ Your Pleasure Cards'),
                        React.createElement('div', { className: 'cards-container' },
                            myStats.pleasureCards.map((card, idx) =>
                                React.createElement('div', {
                                    className: 'card',
                                    key: idx,
                                    style: { borderColor: '#ec4899', background: '#fef2f2' }
                                },
                                    React.createElement('div', { className: 'card-type' }, 'pleasure'),
                                    React.createElement('div', { className: 'card-name' }, card.name),
                                    card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                    card.duration && React.createElement('div', { className: 'card-description' }, card.duration)
                                )
                            )
                        )
                    ),

                    React.createElement('div', { className: 'hand-section' },
                        React.createElement('div', { className: 'hand-header' }, 'ğŸ´ Your Hand'),
                        React.createElement('div', { className: 'cards-container' },
                            myHand.map(card =>
                                React.createElement('div', {
                                    className: `card ${card.type} ${selectedCards.find(c => c.id === card.id) ? 'selected' : ''}`,
                                    key: card.id,
                                    onClick: () => handleCardClick(card)
                                },
                                    React.createElement('div', { className: 'card-type' }, card.type),
                                    React.createElement('div', { className: 'card-name' }, card.name),
                                    card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                    card.duration !== undefined && React.createElement('div', { className: 'card-description' },
                                        `Duration: ${card.duration}s`
                                    )
                                )
                            )
                        )
                    ),

                    React.createElement('div', { className: 'actions-section' },
                        React.createElement('button', {
                            className: 'btn-primary',
                            onClick: handleDrawCard,
                            disabled: !isMyTurn() || myHand.length >= 6
                        }, 'ğŸ“¥ Draw Card'),
                        React.createElement('button', {
                            className: 'btn-secondary',
                            onClick: handlePlaySet,
                            disabled: !canPlaySet()
                        }, 'âœ… Play Set (3 cards)'),
                        React.createElement('button', {
                            className: 'btn-danger',
                            onClick: handleDiscard,
                            disabled: !isMyTurn() || selectedCards.length !== 1
                        }, 'ğŸ—‘ï¸ Discard'),
                        isPlayer1 && React.createElement('button', {
                            className: 'btn-secondary',
                            onClick: handleDrawEquipment,
                            disabled: !isMyTurn() || myStats.points < 1 || gameState.queue.length === 0
                        }, 'ğŸ”§ Add Equipment (1pt)')
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
