<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The GAME - P2P Card Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Only minimal custom styles - everything else uses Bootstrap */
        .game-card { min-width: 140px; cursor: pointer; transition: transform 0.2s; }
        .game-card:hover { transform: translateY(-4px); }
        .log-container { max-height: 200px; overflow-y: auto; }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="cards.js"></script>
</head>
<body>
    <div id="root"></div>

    <script>
        const { useState, useEffect, useRef } = React;

        // Import card data
        const { GAME_CARDS, getAllMainDeckCards, shuffleDeck } = window;

        function App() {
            const [logs, setLogs] = useState([]);
            const [status, setStatus] = useState('initializing');
            const [isPlayer1, setIsPlayer1] = useState(false);
            const [gameLink, setGameLink] = useState('');
            const [connected, setConnected] = useState(false);

            // Game state
            const [gameState, setGameState] = useState(null);
            const [selectedCards, setSelectedCards] = useState([]);
            const [winner, setWinner] = useState(null);
            const [sessionId, setSessionId] = useState(null);
            const [showAskDialog, setShowAskDialog] = useState(false);
            const [askingCardType, setAskingCardType] = useState(null);

            const peerRef = useRef(null);
            const connRef = useRef(null);
            const qrRef = useRef(null);

            const addLog = (message) => {
                const time = new Date().toLocaleTimeString();
                setLogs(prev => [...prev, { time, message }]);
            };

            // Save session to localStorage
            const saveSession = (peerId, isP1, gState) => {
                const session = {
                    peerId,
                    isPlayer1: isP1,
                    gameState: gState,
                    timestamp: Date.now()
                };
                localStorage.setItem('gameSession', JSON.stringify(session));
                setSessionId(peerId);
            };

            // Load session from localStorage
            const loadSession = () => {
                const saved = localStorage.getItem('gameSession');
                if (saved) {
                    const session = JSON.parse(saved);
                    // Session expires after 24 hours
                    if (Date.now() - session.timestamp < 24 * 60 * 60 * 1000) {
                        return session;
                    }
                    localStorage.removeItem('gameSession');
                }
                return null;
            };

            // Clear session
            const clearSession = () => {
                localStorage.removeItem('gameSession');
                setSessionId(null);
                window.location.href = window.location.pathname;
            };

            // Initialize game state
            const initializeGame = (asPlayer1) => {
                const mainDeck = shuffleDeck(getAllMainDeckCards());
                const equipmentDeck = shuffleDeck([...GAME_CARDS.equipmentDeck]);
                const pleasureDeck = shuffleDeck([...GAME_CARDS.pleasureDeck]);

                const state = {
                    mainDeck,
                    equipmentDeck,
                    pleasureDeck,
                    player1: {
                        hand: mainDeck.splice(0, 5),
                        points: 0,
                    },
                    player2: {
                        hand: mainDeck.splice(0, 5),
                        pleasureCards: [],
                    },
                    queue: [],
                    currentTurn: 1, // 1 or 2
                    discardPile: [],
                };

                return state;
            };

            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const peerId = urlParams.get('peer');

                // Try to load saved session
                const savedSession = loadSession();

                if (!peerId) {
                    // Player 1: Create peer and wait for connection
                    setIsPlayer1(true);

                    // Restore session if exists
                    if (savedSession && savedSession.isPlayer1) {
                        addLog('Restoring previous session...');
                        if (savedSession.gameState) {
                            setGameState(savedSession.gameState);
                        }
                    } else {
                        addLog('Initializing as Player 1...');
                    }

                    const peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', (id) => {
                        addLog(`Peer created with ID: ${id}`);
                        const link = `${window.location.origin}${window.location.pathname}?peer=${id}`;
                        setGameLink(link);
                        setStatus('waiting');
                        setSessionId(id);
                        addLog('Waiting for Player 2 to connect...');
                        addLog('Share the link below to invite them!');

                        // Generate QR code
                        setTimeout(() => {
                            if (qrRef.current && window.QRCode) {
                                qrRef.current.innerHTML = '';
                                new QRCode(qrRef.current, {
                                    text: link,
                                    width: 200,
                                    height: 200,
                                    colorDark: '#000000',
                                    colorLight: '#ffffff',
                                    correctLevel: QRCode.CorrectLevel.M
                                });
                            }
                        }, 100);
                    });

                    peer.on('connection', (conn) => {
                        addLog('Player 2 is connecting...');
                        connRef.current = conn;
                        setupConnection(conn, true);
                    });

                    peer.on('error', (err) => {
                        addLog(`Error: ${err.message}`);
                    });

                } else {
                    // Player 2: Connect to Player 1
                    setIsPlayer1(false);
                    addLog('Initializing as Player 2...');
                    setStatus('connecting');

                    const peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', () => {
                        addLog('Peer initialized');
                        addLog(`Connecting to Player 1 (ID: ${peerId})...`);

                        const conn = peer.connect(peerId, {
                            reliable: true
                        });

                        connRef.current = conn;
                        setupConnection(conn, false);
                    });

                    peer.on('error', (err) => {
                        addLog(`Error: ${err.message}`);
                    });
                }

                return () => {
                    if (connRef.current) {
                        connRef.current.close();
                    }
                    if (peerRef.current) {
                        peerRef.current.destroy();
                    }
                };
            }, []);

            // Auto-save game state changes
            useEffect(() => {
                if (gameState && sessionId && isPlayer1) {
                    saveSession(sessionId, isPlayer1, gameState);
                }
            }, [gameState]);

            const setupConnection = (conn, asPlayer1) => {
                conn.on('open', () => {
                    addLog('Connection opened!');
                    addLog('ICE route finding complete');
                    setStatus('connected');
                    setConnected(true);

                    if (asPlayer1) {
                        // Player 1 initializes the game or uses saved state
                        let initialState = gameState;
                        if (!initialState) {
                            initialState = initializeGame(true);
                            setGameState(initialState);
                        }
                        sendGameState(initialState);
                        // Save session
                        saveSession(peerRef.current?.id, true, initialState);
                        addLog('Game initialized! Player 1 starts.');
                    } else {
                        addLog('Waiting for game initialization...');
                    }
                });

                conn.on('data', (data) => {
                    handleMessage(data);
                });

                conn.on('close', () => {
                    addLog('Connection closed');
                    setConnected(false);
                    setStatus('disconnected');
                });

                conn.on('error', (err) => {
                    addLog(`Connection error: ${err.message}`);
                });
            };

            const sendGameState = (state) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'gameState',
                        state: state
                    });
                }
            };

            const sendAction = (action) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'action',
                        action: action
                    });
                }
            };

            const handleMessage = (data) => {
                if (data.type === 'gameState') {
                    setGameState(data.state);
                    // Save updated state
                    if (sessionId) {
                        saveSession(sessionId, isPlayer1, data.state);
                    }
                    addLog('Game state updated');
                } else if (data.type === 'action') {
                    processAction(data.action);
                } else if (data.type === 'winner') {
                    setWinner(data.winner === 'opponent' ? 'opponent' : 'me');
                    addLog(data.winner === 'opponent' ? 'Opponent won!' : 'You won!');
                }
            };

            const processAction = (action) => {
                // Process opponent's action and update game state
                setGameState(prevState => {
                    const newState = { ...prevState };

                    switch (action.type) {
                        case 'playSet':
                            // Add set to queue
                            newState.queue.push(action.set);
                            // Update player stats
                            if (action.player === 1) {
                                newState.player1.points += 1;
                            }
                            // Switch turn
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent played a set`);
                            break;

                        case 'discard':
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent discarded a card`);
                            break;

                        case 'drawEquipment':
                            addLog(`Opponent drew equipment`);
                            break;

                        case 'drawPleasure':
                            addLog(`Opponent drew a pleasure card`);
                            break;

                        case 'stealCard':
                            addLog(`Opponent used Steal Card`);
                            break;

                        case 'askForCard':
                            addLog(`Opponent used Ask For Card (${action.requestedType})`);
                            break;
                    }

                    return newState;
                });
            };

            const handleCardClick = (card) => {
                if (!isMyTurn()) return;

                setSelectedCards(prev => {
                    const isSelected = prev.find(c => c.id === card.id);
                    if (isSelected) {
                        return prev.filter(c => c.id !== card.id);
                    } else {
                        return [...prev, card];
                    }
                });
            };

            const isMyTurn = () => {
                if (!gameState) return false;
                return (isPlayer1 && gameState.currentTurn === 1) ||
                       (!isPlayer1 && gameState.currentTurn === 2);
            };

            const canPlaySet = () => {
                if (selectedCards.length !== 3) return false;
                const hasPosition = selectedCards.some(c => c.type === 'position');
                const hasIntensity = selectedCards.some(c => c.type === 'intensity');
                const hasTime = selectedCards.some(c => c.type === 'time');
                return hasPosition && hasIntensity && hasTime;
            };

            const handleDrawCard = () => {
                if (!isMyTurn() || !gameState) return;

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    if (newState.mainDeck.length > 0) {
                        const drawnCard = newState.mainDeck.shift();
                        newState[playerKey].hand.push(drawnCard);
                        addLog(`Drew: ${drawnCard.name}`);
                    }

                    // Send state after update
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });
            };

            const handlePlaySet = () => {
                if (!canPlaySet() || !gameState) return;

                const position = selectedCards.find(c => c.type === 'position');
                const intensity = selectedCards.find(c => c.type === 'intensity');
                const time = selectedCards.find(c => c.type === 'time');

                const set = {
                    position,
                    intensity,
                    time,
                    equipment: []
                };

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove cards from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => !selectedCards.find(sc => sc.id === c.id)
                    );

                    // Add to queue
                    newState.queue.push(set);

                    // Update player stats
                    if (isPlayer1) {
                        newState.player1.points += 1;
                    } else {
                        // Player 2 draws pleasure card
                        if (newState.pleasureDeck.length > 0) {
                            const pleasureCard = newState.pleasureDeck.shift();
                            newState.player2.pleasureCards.push(pleasureCard);
                            addLog(`Drew pleasure: ${pleasureCard.name}`);
                        }
                    }

                    // Check win conditions
                    let hasWon = false;
                    if (newState.queue.length >= 5 && isPlayer1) {
                        hasWon = true;
                    } else if (newState.player2.pleasureCards.length >= 5 && !isPlayer1) {
                        hasWon = true;
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    addLog(`Played set: ${position.name} + ${intensity.name} + ${time.name}`);

                    // Notify about win
                    if (hasWon) {
                        setWinner('me');
                        setTimeout(() => {
                            if (connRef.current && connRef.current.open) {
                                connRef.current.send({
                                    type: 'winner',
                                    winner: 'opponent'
                                });
                            }
                        }, 100);
                    }

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'playSet',
                    player: isPlayer1 ? 1 : 2,
                    set
                };
                sendAction(action);

                // Use setTimeout to ensure state is updated before sending
                setTimeout(() => {
                    if (connRef.current && connRef.current.open && gameState) {
                        sendGameState(gameState);
                    }
                }, 50);
            };

            const handleDiscard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || !gameState) return;

                const discardedCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== discardedCard.id
                    );

                    // Add to discard pile
                    newState.discardPile.push(discardedCard);

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    addLog(`Discarded: ${discardedCard.name}`);

                    // Send updated state
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'discard'
                };
                sendAction(action);
            };

            const handleDrawEquipment = () => {
                if (!isPlayer1 || !isMyTurn() || !gameState || gameState.player1.points < 1) return;

                setGameState(prev => {
                    const newState = { ...prev };

                    if (newState.equipmentDeck.length > 0 && newState.queue.length > 0) {
                        const equipment = newState.equipmentDeck.shift();
                        newState.queue[newState.queue.length - 1].equipment.push(equipment);
                        newState.player1.points -= 1;
                        addLog(`Added equipment: ${equipment.name}`);

                        // Send updated state
                        setTimeout(() => {
                            sendGameState(newState);
                        }, 50);
                    }

                    return newState;
                });

                const action = {
                    type: 'drawEquipment'
                };
                sendAction(action);
            };

            // Handle playing a special card (Steal Card)
            const handleStealCard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || selectedCards[0].type !== 'special' || selectedCards[0].action !== 'steal') return;

                const specialCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';
                    const opponentKey = isPlayer1 ? 'player2' : 'player1';

                    // Remove special card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== specialCard.id
                    );

                    // Discard the special card
                    newState.discardPile.push(specialCard);

                    // Steal random card from opponent if they have any
                    if (newState[opponentKey].hand.length > 0) {
                        const randomIndex = Math.floor(Math.random() * newState[opponentKey].hand.length);
                        const stolenCard = newState[opponentKey].hand.splice(randomIndex, 1)[0];
                        newState[playerKey].hand.push(stolenCard);
                        addLog(`Stole ${stolenCard.name} from opponent!`);
                    } else {
                        addLog('Opponent has no cards to steal');
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'stealCard',
                    cardId: specialCard.id
                };
                sendAction(action);
            };

            // Handle "Ask For Card" - show dialog
            const handleAskForCard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || selectedCards[0].type !== 'special' || selectedCards[0].action !== 'ask') return;
                setShowAskDialog(true);
            };

            // Execute ask for card with selected type
            const executeAskForCard = (cardType) => {
                if (!cardType) return;

                const specialCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';
                    const opponentKey = isPlayer1 ? 'player2' : 'player1';

                    // Remove special card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== specialCard.id
                    );

                    // Discard the special card
                    newState.discardPile.push(specialCard);

                    // Find card of requested type from opponent
                    const requestedCard = newState[opponentKey].hand.find(c => c.type === cardType);
                    if (requestedCard) {
                        newState[opponentKey].hand = newState[opponentKey].hand.filter(c => c.id !== requestedCard.id);
                        newState[playerKey].hand.push(requestedCard);
                        addLog(`Received ${requestedCard.name} from opponent!`);
                    } else {
                        addLog(`Opponent doesn't have a ${cardType} card`);
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);
                setShowAskDialog(false);

                const action = {
                    type: 'askForCard',
                    cardId: specialCard.id,
                    requestedType: cardType
                };
                sendAction(action);
            };

            const copyLink = async () => {
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(gameLink);
                        addLog('Link copied to clipboard!');
                    } else {
                        const textarea = document.createElement('textarea');
                        textarea.value = gameLink;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        addLog('Link copied to clipboard!');
                    }
                } catch (err) {
                    addLog('Failed to copy link');
                }
            };

            const shareLink = async () => {
                if (navigator.share) {
                    try {
                        await navigator.share({
                            title: 'The GAME',
                            text: 'Join me in a card game!',
                            url: gameLink
                        });
                        addLog('Link shared!');
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            addLog('Share failed, use copy instead');
                        }
                    }
                } else {
                    copyLink();
                }
            };

            const myHand = gameState && (isPlayer1 ? gameState.player1.hand : gameState.player2.hand);
            const myStats = gameState && (isPlayer1 ? gameState.player1 : gameState.player2);

            return React.createElement('div', { className: 'container my-4' },
                React.createElement('h1', { className: 'text-center mb-4' }, 'üé¥ The GAME'),

                React.createElement('div', {
                    className: `alert text-center fw-bold ${status === 'waiting' ? 'alert-warning' : status === 'connecting' ? 'alert-info' : status === 'connected' ? 'alert-success' : 'alert-secondary'}`
                },
                    status === 'waiting' ? '‚è≥ Waiting for Player 2...' :
                    status === 'connecting' ? 'üîÑ Connecting...' :
                    status === 'connected' ? '‚úÖ Connected!' : 'üîß Initializing...'
                ),

                React.createElement('div', { className: 'log-container border rounded p-3 mb-3 bg-light' },
                    logs.map((log, i) =>
                        React.createElement('div', { className: 'border-start border-primary border-3 bg-white rounded p-2 mb-1 small', key: i },
                            React.createElement('span', { className: 'text-muted me-2 small' }, log.time),
                            React.createElement('span', null, log.message)
                        )
                    )
                ),

                !connected && isPlayer1 && gameLink && React.createElement('div', null,
                    React.createElement('div', { className: 'alert alert-info' },
                        React.createElement('strong', null, 'üìã Instructions:'),
                        React.createElement('ol', null,
                            React.createElement('li', null, 'Scan the QR code with your phone, OR'),
                            React.createElement('li', null, 'Copy/share the link below'),
                            React.createElement('li', null, 'Send it to a friend'),
                            React.createElement('li', null, 'Wait for them to open it'),
                            React.createElement('li', null, 'Connection will establish automatically!')
                        )
                    ),
                    React.createElement('div', { className: 'border rounded p-4 mb-3 bg-light text-center' },
                        React.createElement('div', {
                            className: 'bg-white p-3 rounded d-inline-block mb-3',
                            ref: qrRef
                        }),
                        React.createElement('div', { className: 'text-muted small' }, 'üì± Scan to join on mobile')
                    ),
                    React.createElement('div', { className: 'border border-secondary border-2 border-dashed rounded p-3 mb-3 bg-light font-monospace small text-break' }, gameLink),
                    React.createElement('div', { className: 'd-flex gap-2 mb-3' },
                        React.createElement('button', {
                            className: 'btn btn-primary flex-fill',
                            onClick: copyLink
                        }, 'üìã Copy Link'),
                        React.createElement('button', {
                            className: 'btn btn-success flex-fill',
                            onClick: shareLink
                        }, 'üì§ Share Link')
                    )
                ),

                !connected && !isPlayer1 && React.createElement('div', { className: 'alert alert-info' },
                    React.createElement('strong', null, 'üîó Connecting to Player 1...'),
                    React.createElement('p', { className: 'mt-2 mb-0' },
                        'This may take 5-10 seconds while finding the best route...'
                    )
                ),

                connected && gameState && React.createElement('div', { className: 'vstack gap-3' },
                    winner && React.createElement('div', {
                        className: `alert text-center fs-4 fw-bold ${winner === 'me' ? 'alert-success' : 'alert-danger'}`
                    },
                        winner === 'me' ? 'üéâ You Won!' : 'üòî You Lost!'
                    ),

                    React.createElement('div', { className: 'card' },
                        React.createElement('div', { className: 'card-body d-flex justify-content-between align-items-center flex-wrap gap-3' },
                        React.createElement('div', null,
                            React.createElement('div', { className: 'fs-5 fw-bold text-primary' },
                                isPlayer1 ? 'üë§ Player 1' : 'üë§ Player 2'
                            ),
                            React.createElement('div', {
                                className: `fw-semibold ${isMyTurn() ? 'text-success' : 'text-muted'}`
                            },
                                isMyTurn() ? '‚úì Your Turn' : '‚è≥ Opponent\'s Turn'
                            )
                        ),
                        React.createElement('div', { className: 'd-flex gap-3 align-items-center flex-wrap' },
                        React.createElement('div', { className: 'd-flex gap-4' },
                            isPlayer1 && React.createElement('div', null,
                                React.createElement('div', { className: 'text-muted small' }, 'Points'),
                                React.createElement('div', { className: 'fs-4 fw-bold' }, myStats.points || 0)
                            ),
                            !isPlayer1 && React.createElement('div', null,
                                React.createElement('div', { className: 'text-muted small' }, 'Pleasure Cards'),
                                React.createElement('div', { className: 'fs-4 fw-bold' }, myStats.pleasureCards.length)
                            ),
                            React.createElement('div', null,
                                React.createElement('div', { className: 'text-muted small' }, 'Hand'),
                                React.createElement('div', { className: 'fs-4 fw-bold' }, myHand.length)
                            )
                        ),
                        isPlayer1 && React.createElement('button', {
                            className: 'btn btn-outline-danger btn-sm',
                            onClick: clearSession
                        }, 'üîÑ New Game')
                    )
                    )
                    ),

                    React.createElement('div', { className: 'alert alert-warning' },
                        React.createElement('div', { className: 'fs-5 fw-bold text-warning-emphasis mb-3' },
                            `üî• Queue (${gameState.queue.length}/5)`
                        ),
                        gameState.queue.length === 0 && React.createElement('div', {
                            className: 'text-warning-emphasis fst-italic'
                        }, 'No punishments queued yet'),
                        React.createElement('div', { className: 'vstack gap-2' },
                            gameState.queue.map((item, idx) =>
                                React.createElement('div', { className: 'card border-warning', key: idx },
                                    React.createElement('div', { className: 'card-body p-3' },
                                    React.createElement('div', { className: 'd-flex gap-2 flex-wrap mb-2' },
                                        React.createElement('span', { className: 'badge bg-primary' }, item.position.name),
                                        React.createElement('span', { className: 'badge bg-danger' }, item.intensity.name),
                                        React.createElement('span', { className: 'badge bg-success' }, item.time.name)
                                    ),
                                    item.equipment && item.equipment.length > 0 &&
                                    React.createElement('div', { className: 'd-flex gap-2 flex-wrap pt-2 border-top' },
                                        item.equipment.map((eq, eqIdx) =>
                                            React.createElement('span', { className: 'badge bg-danger-subtle text-danger-emphasis', key: eqIdx }, eq.name)
                                        )
                                    )
                                )
                                )
                            )
                        )
                    ),

                    !isPlayer1 && myStats.pleasureCards.length > 0 && React.createElement('div', { className: 'card border-danger' },
                        React.createElement('div', { className: 'card-header bg-danger-subtle' },
                            React.createElement('h5', { className: 'mb-0 text-danger-emphasis' }, 'üíù Your Pleasure Cards')
                        ),
                        React.createElement('div', { className: 'card-body' },
                            React.createElement('div', { className: 'd-flex gap-3 flex-wrap' },
                                myStats.pleasureCards.map((card, idx) =>
                                    React.createElement('div', {
                                        className: 'game-card card border-danger bg-danger-subtle',
                                        key: idx
                                    },
                                        React.createElement('div', { className: 'card-body p-3' },
                                            React.createElement('div', { className: 'small text-uppercase fw-bold text-muted mb-1' }, 'pleasure'),
                                            React.createElement('div', { className: 'fw-bold mb-1' }, card.name),
                                            card.description && React.createElement('div', { className: 'small text-muted' }, card.description),
                                            card.duration && React.createElement('div', { className: 'small text-muted' }, card.duration)
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    React.createElement('div', { className: 'card' },
                        React.createElement('div', { className: 'card-header bg-light' },
                            React.createElement('h5', { className: 'mb-0' }, 'üé¥ Your Hand')
                        ),
                        React.createElement('div', { className: 'card-body' },
                            React.createElement('div', { className: 'd-flex gap-3 flex-wrap' },
                                myHand.map(card =>
                                    React.createElement('div', {
                                        className: `game-card card border-3 ${selectedCards.find(c => c.id === card.id) ? 'border-primary bg-primary-subtle' : card.type === 'position' ? 'border-primary' : card.type === 'intensity' ? 'border-danger' : card.type === 'time' ? 'border-success' : 'border-warning'}`,
                                        key: card.id,
                                        onClick: () => handleCardClick(card)
                                    },
                                        React.createElement('div', { className: 'card-body p-3' },
                                            React.createElement('div', { className: 'small text-uppercase fw-bold text-muted mb-1' }, card.type),
                                            React.createElement('div', { className: 'fw-bold mb-1' }, card.name),
                                            card.description && React.createElement('div', { className: 'small text-muted' }, card.description),
                                            card.duration !== undefined && React.createElement('div', { className: 'small text-muted' },
                                                `Duration: ${card.duration}s`
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    React.createElement('div', { className: 'd-flex gap-2 flex-wrap' },
                        React.createElement('button', {
                            className: 'btn btn-primary',
                            onClick: handleDrawCard,
                            disabled: !isMyTurn() || myHand.length >= 6
                        }, 'üì• Draw Card'),
                        React.createElement('button', {
                            className: 'btn btn-success',
                            onClick: handlePlaySet,
                            disabled: !canPlaySet()
                        }, '‚úÖ Play Set (3 cards)'),
                        React.createElement('button', {
                            className: 'btn btn-danger',
                            onClick: handleDiscard,
                            disabled: !isMyTurn() || selectedCards.length !== 1 || selectedCards[0].type === 'special'
                        }, 'üóëÔ∏è Discard'),
                        React.createElement('button', {
                            className: 'btn btn-info',
                            onClick: handleStealCard,
                            disabled: !isMyTurn() || selectedCards.length !== 1 || selectedCards[0]?.type !== 'special' || selectedCards[0]?.action !== 'steal'
                        }, 'üÉè Steal Card'),
                        React.createElement('button', {
                            className: 'btn btn-info',
                            onClick: handleAskForCard,
                            disabled: !isMyTurn() || selectedCards.length !== 1 || selectedCards[0]?.type !== 'special' || selectedCards[0]?.action !== 'ask'
                        }, '‚ùì Ask For Card'),
                        isPlayer1 && React.createElement('button', {
                            className: 'btn btn-warning',
                            onClick: handleDrawEquipment,
                            disabled: !isMyTurn() || myStats.points < 1 || gameState.queue.length === 0
                        }, 'üîß Add Equipment (1pt)')
                    ),

                    showAskDialog && React.createElement('div', {
                        className: 'modal show d-block',
                        style: { backgroundColor: 'rgba(0,0,0,0.5)' },
                        onClick: () => setShowAskDialog(false)
                    },
                        React.createElement('div', {
                            className: 'modal-dialog modal-dialog-centered',
                            onClick: (e) => e.stopPropagation()
                        },
                            React.createElement('div', { className: 'modal-content' },
                                React.createElement('div', { className: 'modal-header' },
                                    React.createElement('h5', { className: 'modal-title' }, '‚ùì Ask For Card Type'),
                                    React.createElement('button', {
                                        type: 'button',
                                        className: 'btn-close',
                                        onClick: () => setShowAskDialog(false)
                                    })
                                ),
                                React.createElement('div', { className: 'modal-body' },
                                    React.createElement('p', null, 'Choose which type of card to request from your opponent:'),
                                    React.createElement('div', { className: 'd-grid gap-2' },
                                        React.createElement('button', {
                                            className: 'btn btn-primary',
                                            onClick: () => executeAskForCard('position')
                                        }, 'üìç Position Card'),
                                        React.createElement('button', {
                                            className: 'btn btn-danger',
                                            onClick: () => executeAskForCard('intensity')
                                        }, 'üí™ Intensity Card'),
                                        React.createElement('button', {
                                            className: 'btn btn-success',
                                            onClick: () => executeAskForCard('time')
                                        }, '‚è±Ô∏è Time Card'),
                                        React.createElement('button', {
                                            className: 'btn btn-warning',
                                            onClick: () => executeAskForCard('special')
                                        }, '‚ú® Special Card')
                                    )
                                ),
                                React.createElement('div', { className: 'modal-footer' },
                                    React.createElement('button', {
                                        className: 'btn btn-secondary',
                                        onClick: () => setShowAskDialog(false)
                                    }, 'Cancel')
                                )
                            )
                        )
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
