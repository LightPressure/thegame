<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The GAME - P2P Card Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="cards.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            font-size: 32px;
            text-align: center;
            margin-bottom: 24px;
            color: #667eea;
        }

        .status {
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
        }

        .status.waiting {
            background: #fef3c7;
            color: #92400e;
        }

        .status.connecting {
            background: #dbeafe;
            color: #1e40af;
        }

        .status.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .log-container {
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            font-size: 14px;
            padding: 8px;
            margin-bottom: 4px;
            border-left: 3px solid #667eea;
            background: white;
            border-radius: 4px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .log-time {
            color: #6b7280;
            font-size: 12px;
            margin-right: 8px;
        }

        .instructions {
            background: #f0f9ff;
            border: 2px solid #0ea5e9;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            font-size: 16px;
            line-height: 1.6;
        }

        .instructions ol {
            margin-left: 20px;
            margin-top: 8px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            background: #9ca3af;
            color: #d1d5db;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #5568d3;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #10b981;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #059669;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #dc2626;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: #f3f4f6;
            border-radius: 8px;
        }

        .player-info {
            flex: 1;
        }

        .player-role {
            font-size: 20px;
            font-weight: 700;
            color: #667eea;
        }

        .turn-indicator {
            font-size: 16px;
            font-weight: 600;
            color: #10b981;
        }

        .turn-indicator.not-your-turn {
            color: #6b7280;
        }

        .player-stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
        }

        .stat {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            color: #6b7280;
            font-size: 12px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #111827;
        }

        .queue-section {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 16px;
        }

        .queue-header {
            font-size: 20px;
            font-weight: 700;
            color: #92400e;
            margin-bottom: 12px;
        }

        .queue-items {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .queue-item {
            background: white;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 12px;
        }

        .queue-set {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .queue-equipment {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px dashed #d1d5db;
        }

        .equipment-tag {
            background: #fce7f3;
            color: #831843;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }

        .hand-section {
            background: #f3f4f6;
            border-radius: 8px;
            padding: 16px;
        }

        .hand-header {
            font-size: 18px;
            font-weight: 700;
            color: #374151;
            margin-bottom: 12px;
        }

        .cards-container {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .card {
            background: white;
            border: 3px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            min-width: 140px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .card.selected {
            border-color: #667eea;
            background: #eef2ff;
        }

        .card.position {
            border-color: #3b82f6;
        }

        .card.intensity {
            border-color: #ef4444;
        }

        .card.time {
            border-color: #10b981;
        }

        .card.special {
            border-color: #f59e0b;
        }

        .card-type {
            font-size: 10px;
            text-transform: uppercase;
            font-weight: 700;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .card-name {
            font-size: 16px;
            font-weight: 700;
            color: #111827;
            margin-bottom: 4px;
        }

        .card-description {
            font-size: 12px;
            color: #6b7280;
        }

        .actions-section {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .winner-banner {
            padding: 24px;
            border-radius: 8px;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 20px;
            animation: pulse 0.5s ease-in-out;
        }

        .winner-banner.win {
            background: #d1fae5;
            color: #065f46;
        }

        .winner-banner.lose {
            background: #fee2e2;
            color: #991b1b;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .link-display {
            background: #f9fafb;
            border: 2px dashed #9ca3af;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            word-break: break-all;
            font-family: monospace;
            font-size: 14px;
            color: #374151;
        }

        .qr-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .qr-code {
            background: white;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .qr-label {
            font-size: 14px;
            color: #6b7280;
            text-align: center;
        }

        .mini-card {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
            color: white;
        }

        .mini-card.position { background: #3b82f6; }
        .mini-card.intensity { background: #ef4444; }
        .mini-card.time { background: #10b981; }

        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }

            h1 {
                font-size: 24px;
            }

            .cards-container {
                gap: 8px;
            }

            .card {
                min-width: 120px;
                padding: 8px;
            }

            .game-info {
                flex-direction: column;
                gap: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script>
        const { useState, useEffect, useRef } = React;

        // Import card data
        const { GAME_CARDS, getAllMainDeckCards, shuffleDeck } = window;

        function App() {
            const [logs, setLogs] = useState([]);
            const [status, setStatus] = useState('initializing');
            const [isPlayer1, setIsPlayer1] = useState(false);
            const [gameLink, setGameLink] = useState('');
            const [connected, setConnected] = useState(false);

            // Game state
            const [gameState, setGameState] = useState(null);
            const [selectedCards, setSelectedCards] = useState([]);
            const [winner, setWinner] = useState(null);

            const peerRef = useRef(null);
            const connRef = useRef(null);
            const qrRef = useRef(null);

            const addLog = (message) => {
                const time = new Date().toLocaleTimeString();
                setLogs(prev => [...prev, { time, message }]);
            };

            // Initialize game state
            const initializeGame = (asPlayer1) => {
                const mainDeck = shuffleDeck(getAllMainDeckCards());
                const equipmentDeck = shuffleDeck([...GAME_CARDS.equipmentDeck]);
                const pleasureDeck = shuffleDeck([...GAME_CARDS.pleasureDeck]);

                const state = {
                    mainDeck,
                    equipmentDeck,
                    pleasureDeck,
                    player1: {
                        hand: mainDeck.splice(0, 5),
                        points: 0,
                    },
                    player2: {
                        hand: mainDeck.splice(0, 5),
                        pleasureCards: [],
                    },
                    queue: [],
                    currentTurn: 1, // 1 or 2
                    discardPile: [],
                };

                return state;
            };

            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const peerId = urlParams.get('peer');

                if (!peerId) {
                    // Player 1: Create peer and wait for connection
                    setIsPlayer1(true);
                    addLog('Initializing as Player 1...');

                    const peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', (id) => {
                        addLog(`Peer created with ID: ${id}`);
                        const link = `${window.location.origin}${window.location.pathname}?peer=${id}`;
                        setGameLink(link);
                        setStatus('waiting');
                        addLog('Waiting for Player 2 to connect...');
                        addLog('Share the link below to invite them!');

                        // Generate QR code
                        setTimeout(() => {
                            if (qrRef.current && window.QRCode) {
                                qrRef.current.innerHTML = '';
                                new QRCode(qrRef.current, {
                                    text: link,
                                    width: 200,
                                    height: 200,
                                    colorDark: '#000000',
                                    colorLight: '#ffffff',
                                    correctLevel: QRCode.CorrectLevel.M
                                });
                            }
                        }, 100);
                    });

                    peer.on('connection', (conn) => {
                        addLog('Player 2 is connecting...');
                        connRef.current = conn;
                        setupConnection(conn, true);
                    });

                    peer.on('error', (err) => {
                        addLog(`Error: ${err.message}`);
                    });

                } else {
                    // Player 2: Connect to Player 1
                    setIsPlayer1(false);
                    addLog('Initializing as Player 2...');
                    setStatus('connecting');

                    const peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', () => {
                        addLog('Peer initialized');
                        addLog(`Connecting to Player 1 (ID: ${peerId})...`);

                        const conn = peer.connect(peerId, {
                            reliable: true
                        });

                        connRef.current = conn;
                        setupConnection(conn, false);
                    });

                    peer.on('error', (err) => {
                        addLog(`Error: ${err.message}`);
                    });
                }

                return () => {
                    if (connRef.current) {
                        connRef.current.close();
                    }
                    if (peerRef.current) {
                        peerRef.current.destroy();
                    }
                };
            }, []);

            const setupConnection = (conn, asPlayer1) => {
                conn.on('open', () => {
                    addLog('Connection opened!');
                    addLog('ICE route finding complete');
                    setStatus('connected');
                    setConnected(true);

                    if (asPlayer1) {
                        // Player 1 initializes the game
                        const initialState = initializeGame(true);
                        setGameState(initialState);
                        sendGameState(initialState);
                        addLog('Game initialized! Player 1 starts.');
                    } else {
                        addLog('Waiting for game initialization...');
                    }
                });

                conn.on('data', (data) => {
                    handleMessage(data);
                });

                conn.on('close', () => {
                    addLog('Connection closed');
                    setConnected(false);
                    setStatus('disconnected');
                });

                conn.on('error', (err) => {
                    addLog(`Connection error: ${err.message}`);
                });
            };

            const sendGameState = (state) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'gameState',
                        state: state
                    });
                }
            };

            const sendAction = (action) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'action',
                        action: action
                    });
                }
            };

            const handleMessage = (data) => {
                if (data.type === 'gameState') {
                    setGameState(data.state);
                    addLog('Game state updated');
                } else if (data.type === 'action') {
                    processAction(data.action);
                } else if (data.type === 'winner') {
                    setWinner(data.winner === 'opponent' ? 'opponent' : 'me');
                    addLog(data.winner === 'opponent' ? 'Opponent won!' : 'You won!');
                }
            };

            const processAction = (action) => {
                // Process opponent's action and update game state
                setGameState(prevState => {
                    const newState = { ...prevState };

                    switch (action.type) {
                        case 'playSet':
                            // Add set to queue
                            newState.queue.push(action.set);
                            // Update player stats
                            if (action.player === 1) {
                                newState.player1.points += 1;
                            }
                            // Switch turn
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent played a set`);
                            break;

                        case 'discard':
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent discarded a card`);
                            break;

                        case 'drawEquipment':
                            addLog(`Opponent drew equipment`);
                            break;

                        case 'drawPleasure':
                            addLog(`Opponent drew a pleasure card`);
                            break;
                    }

                    return newState;
                });
            };

            const handleCardClick = (card) => {
                if (!isMyTurn()) return;

                setSelectedCards(prev => {
                    const isSelected = prev.find(c => c.id === card.id);
                    if (isSelected) {
                        return prev.filter(c => c.id !== card.id);
                    } else {
                        return [...prev, card];
                    }
                });
            };

            const isMyTurn = () => {
                if (!gameState) return false;
                return (isPlayer1 && gameState.currentTurn === 1) ||
                       (!isPlayer1 && gameState.currentTurn === 2);
            };

            const canPlaySet = () => {
                if (selectedCards.length !== 3) return false;
                const hasPosition = selectedCards.some(c => c.type === 'position');
                const hasIntensity = selectedCards.some(c => c.type === 'intensity');
                const hasTime = selectedCards.some(c => c.type === 'time');
                return hasPosition && hasIntensity && hasTime;
            };

            const handleDrawCard = () => {
                if (!isMyTurn() || !gameState) return;

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    if (newState.mainDeck.length > 0) {
                        const drawnCard = newState.mainDeck.shift();
                        newState[playerKey].hand.push(drawnCard);
                        addLog(`Drew: ${drawnCard.name}`);
                    }

                    // Send state after update
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });
            };

            const handlePlaySet = () => {
                if (!canPlaySet() || !gameState) return;

                const position = selectedCards.find(c => c.type === 'position');
                const intensity = selectedCards.find(c => c.type === 'intensity');
                const time = selectedCards.find(c => c.type === 'time');

                const set = {
                    position,
                    intensity,
                    time,
                    equipment: []
                };

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove cards from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => !selectedCards.find(sc => sc.id === c.id)
                    );

                    // Add to queue
                    newState.queue.push(set);

                    // Update player stats
                    if (isPlayer1) {
                        newState.player1.points += 1;
                    } else {
                        // Player 2 draws pleasure card
                        if (newState.pleasureDeck.length > 0) {
                            const pleasureCard = newState.pleasureDeck.shift();
                            newState.player2.pleasureCards.push(pleasureCard);
                            addLog(`Drew pleasure: ${pleasureCard.name}`);
                        }
                    }

                    // Check win conditions
                    let hasWon = false;
                    if (newState.queue.length >= 5 && isPlayer1) {
                        hasWon = true;
                    } else if (newState.player2.pleasureCards.length >= 5 && !isPlayer1) {
                        hasWon = true;
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    addLog(`Played set: ${position.name} + ${intensity.name} + ${time.name}`);

                    // Notify about win
                    if (hasWon) {
                        setWinner('me');
                        setTimeout(() => {
                            if (connRef.current && connRef.current.open) {
                                connRef.current.send({
                                    type: 'winner',
                                    winner: 'opponent'
                                });
                            }
                        }, 100);
                    }

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'playSet',
                    player: isPlayer1 ? 1 : 2,
                    set
                };
                sendAction(action);

                // Use setTimeout to ensure state is updated before sending
                setTimeout(() => {
                    if (connRef.current && connRef.current.open && gameState) {
                        sendGameState(gameState);
                    }
                }, 50);
            };

            const handleDiscard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || !gameState) return;

                const discardedCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== discardedCard.id
                    );

                    // Add to discard pile
                    newState.discardPile.push(discardedCard);

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    addLog(`Discarded: ${discardedCard.name}`);

                    // Send updated state
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'discard'
                };
                sendAction(action);
            };

            const handleDrawEquipment = () => {
                if (!isPlayer1 || !isMyTurn() || !gameState || gameState.player1.points < 1) return;

                setGameState(prev => {
                    const newState = { ...prev };

                    if (newState.equipmentDeck.length > 0 && newState.queue.length > 0) {
                        const equipment = newState.equipmentDeck.shift();
                        newState.queue[newState.queue.length - 1].equipment.push(equipment);
                        newState.player1.points -= 1;
                        addLog(`Added equipment: ${equipment.name}`);

                        // Send updated state
                        setTimeout(() => {
                            sendGameState(newState);
                        }, 50);
                    }

                    return newState;
                });

                const action = {
                    type: 'drawEquipment'
                };
                sendAction(action);
            };

            const copyLink = async () => {
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(gameLink);
                        addLog('Link copied to clipboard!');
                    } else {
                        const textarea = document.createElement('textarea');
                        textarea.value = gameLink;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        addLog('Link copied to clipboard!');
                    }
                } catch (err) {
                    addLog('Failed to copy link');
                }
            };

            const shareLink = async () => {
                if (navigator.share) {
                    try {
                        await navigator.share({
                            title: 'The GAME',
                            text: 'Join me in a card game!',
                            url: gameLink
                        });
                        addLog('Link shared!');
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            addLog('Share failed, use copy instead');
                        }
                    }
                } else {
                    copyLink();
                }
            };

            const myHand = gameState && (isPlayer1 ? gameState.player1.hand : gameState.player2.hand);
            const myStats = gameState && (isPlayer1 ? gameState.player1 : gameState.player2);

            return React.createElement('div', { className: 'container' },
                React.createElement('h1', null, 'üé¥ The GAME'),

                React.createElement('div', {
                    className: `status ${status === 'waiting' ? 'waiting' : status === 'connecting' ? 'connecting' : status === 'connected' ? 'connected' : ''}`
                },
                    status === 'waiting' ? '‚è≥ Waiting for Player 2...' :
                    status === 'connecting' ? 'üîÑ Connecting...' :
                    status === 'connected' ? '‚úÖ Connected!' : 'üîß Initializing...'
                ),

                React.createElement('div', { className: 'log-container' },
                    logs.map((log, i) =>
                        React.createElement('div', { className: 'log-entry', key: i },
                            React.createElement('span', { className: 'log-time' }, log.time),
                            React.createElement('span', null, log.message)
                        )
                    )
                ),

                !connected && isPlayer1 && gameLink && React.createElement('div', null,
                    React.createElement('div', { className: 'instructions' },
                        React.createElement('strong', null, 'üìã Instructions:'),
                        React.createElement('ol', null,
                            React.createElement('li', null, 'Scan the QR code with your phone, OR'),
                            React.createElement('li', null, 'Copy/share the link below'),
                            React.createElement('li', null, 'Send it to a friend'),
                            React.createElement('li', null, 'Wait for them to open it'),
                            React.createElement('li', null, 'Connection will establish automatically!')
                        )
                    ),
                    React.createElement('div', { className: 'qr-container' },
                        React.createElement('div', {
                            className: 'qr-code',
                            ref: qrRef
                        }),
                        React.createElement('div', { className: 'qr-label' }, 'üì± Scan to join on mobile')
                    ),
                    React.createElement('div', { className: 'link-display' }, gameLink),
                    React.createElement('div', { className: 'button-group' },
                        React.createElement('button', {
                            className: 'btn-primary',
                            onClick: copyLink
                        }, 'üìã Copy Link'),
                        React.createElement('button', {
                            className: 'btn-secondary',
                            onClick: shareLink
                        }, 'üì§ Share Link')
                    )
                ),

                !connected && !isPlayer1 && React.createElement('div', { className: 'instructions' },
                    React.createElement('strong', null, 'üîó Connecting to Player 1...'),
                    React.createElement('p', { style: { marginTop: '12px' } },
                        'This may take 5-10 seconds while finding the best route...'
                    )
                ),

                connected && gameState && React.createElement('div', { className: 'game-container' },
                    winner && React.createElement('div', {
                        className: `winner-banner ${winner === 'me' ? 'win' : 'lose'}`
                    },
                        winner === 'me' ? 'üéâ You Won!' : 'üòî You Lost!'
                    ),

                    React.createElement('div', { className: 'game-info' },
                        React.createElement('div', { className: 'player-info' },
                            React.createElement('div', { className: 'player-role' },
                                isPlayer1 ? 'üë§ Player 1' : 'üë§ Player 2'
                            ),
                            React.createElement('div', {
                                className: isMyTurn() ? 'turn-indicator' : 'turn-indicator not-your-turn'
                            },
                                isMyTurn() ? '‚úì Your Turn' : '‚è≥ Opponent\'s Turn'
                            )
                        ),
                        React.createElement('div', { className: 'player-stats' },
                            isPlayer1 && React.createElement('div', { className: 'stat' },
                                React.createElement('div', { className: 'stat-label' }, 'Points'),
                                React.createElement('div', { className: 'stat-value' }, myStats.points || 0)
                            ),
                            !isPlayer1 && React.createElement('div', { className: 'stat' },
                                React.createElement('div', { className: 'stat-label' }, 'Pleasure Cards'),
                                React.createElement('div', { className: 'stat-value' }, myStats.pleasureCards.length)
                            ),
                            React.createElement('div', { className: 'stat' },
                                React.createElement('div', { className: 'stat-label' }, 'Hand'),
                                React.createElement('div', { className: 'stat-value' }, myHand.length)
                            )
                        )
                    ),

                    React.createElement('div', { className: 'queue-section' },
                        React.createElement('div', { className: 'queue-header' },
                            `üî• Queue (${gameState.queue.length}/5)`
                        ),
                        gameState.queue.length === 0 && React.createElement('div', {
                            style: { color: '#92400e', fontStyle: 'italic' }
                        }, 'No punishments queued yet'),
                        React.createElement('div', { className: 'queue-items' },
                            gameState.queue.map((item, idx) =>
                                React.createElement('div', { className: 'queue-item', key: idx },
                                    React.createElement('div', { className: 'queue-set' },
                                        React.createElement('span', { className: 'mini-card position' }, item.position.name),
                                        React.createElement('span', { className: 'mini-card intensity' }, item.intensity.name),
                                        React.createElement('span', { className: 'mini-card time' }, item.time.name)
                                    ),
                                    item.equipment && item.equipment.length > 0 &&
                                    React.createElement('div', { className: 'queue-equipment' },
                                        item.equipment.map((eq, eqIdx) =>
                                            React.createElement('span', { className: 'equipment-tag', key: eqIdx }, eq.name)
                                        )
                                    )
                                )
                            )
                        )
                    ),

                    !isPlayer1 && myStats.pleasureCards.length > 0 && React.createElement('div', { className: 'hand-section', style: { background: '#fce7f3', border: '2px solid #ec4899' } },
                        React.createElement('div', { className: 'hand-header', style: { color: '#831843' } }, 'üíù Your Pleasure Cards'),
                        React.createElement('div', { className: 'cards-container' },
                            myStats.pleasureCards.map((card, idx) =>
                                React.createElement('div', {
                                    className: 'card',
                                    key: idx,
                                    style: { borderColor: '#ec4899', background: '#fef2f2' }
                                },
                                    React.createElement('div', { className: 'card-type' }, 'pleasure'),
                                    React.createElement('div', { className: 'card-name' }, card.name),
                                    card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                    card.duration && React.createElement('div', { className: 'card-description' }, card.duration)
                                )
                            )
                        )
                    ),

                    React.createElement('div', { className: 'hand-section' },
                        React.createElement('div', { className: 'hand-header' }, 'üé¥ Your Hand'),
                        React.createElement('div', { className: 'cards-container' },
                            myHand.map(card =>
                                React.createElement('div', {
                                    className: `card ${card.type} ${selectedCards.find(c => c.id === card.id) ? 'selected' : ''}`,
                                    key: card.id,
                                    onClick: () => handleCardClick(card)
                                },
                                    React.createElement('div', { className: 'card-type' }, card.type),
                                    React.createElement('div', { className: 'card-name' }, card.name),
                                    card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                    card.duration !== undefined && React.createElement('div', { className: 'card-description' },
                                        `Duration: ${card.duration}s`
                                    )
                                )
                            )
                        )
                    ),

                    React.createElement('div', { className: 'actions-section' },
                        React.createElement('button', {
                            className: 'btn-primary',
                            onClick: handleDrawCard,
                            disabled: !isMyTurn() || myHand.length >= 6
                        }, 'üì• Draw Card'),
                        React.createElement('button', {
                            className: 'btn-secondary',
                            onClick: handlePlaySet,
                            disabled: !canPlaySet()
                        }, '‚úÖ Play Set (3 cards)'),
                        React.createElement('button', {
                            className: 'btn-danger',
                            onClick: handleDiscard,
                            disabled: !isMyTurn() || selectedCards.length !== 1
                        }, 'üóëÔ∏è Discard'),
                        isPlayer1 && React.createElement('button', {
                            className: 'btn-secondary',
                            onClick: handleDrawEquipment,
                            disabled: !isMyTurn() || myStats.points < 1 || gameState.queue.length === 0
                        }, 'üîß Add Equipment (1pt)')
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
