<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The GAME - P2P Card Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Romantic/Sensual Theme */
        :root {
            --primary-dark: #1a0d1f;
            --primary-purple: #4a1942;
            --secondary-pink: #d4506b;
            --accent-rose: #e8768f;
            --soft-cream: #fff5f7;
            --card-bg: linear-gradient(135deg, #2d1537 0%, #1f0e29 100%);
        }

        body {
            background: linear-gradient(135deg, #1a0d1f 0%, #2d1537 50%, #1a0d1f 100%);
            min-height: 100vh;
            color: var(--soft-cream);
            position: relative;
            overflow-x: hidden;
        }

        /* Sparkle effects */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(2px 2px at 20% 30%, rgba(232, 118, 143, 0.4), transparent),
                radial-gradient(2px 2px at 60% 70%, rgba(212, 80, 107, 0.3), transparent),
                radial-gradient(1px 1px at 50% 50%, rgba(255, 255, 255, 0.3), transparent),
                radial-gradient(2px 2px at 80% 10%, rgba(232, 118, 143, 0.4), transparent),
                radial-gradient(1px 1px at 90% 60%, rgba(255, 255, 255, 0.2), transparent),
                radial-gradient(2px 2px at 30% 80%, rgba(212, 80, 107, 0.3), transparent),
                radial-gradient(1px 1px at 15% 90%, rgba(232, 118, 143, 0.4), transparent);
            background-size: 200% 200%;
            background-position: 0% 0%;
            animation: sparkle 20s ease-in-out infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes sparkle {
            0%, 100% {
                opacity: 0.3;
                background-position: 0% 0%;
            }
            50% {
                opacity: 0.6;
                background-position: 100% 100%;
            }
        }

        .container {
            position: relative;
            z-index: 1;
        }

        .container {
            background: rgba(42, 21, 50, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(212, 80, 107, 0.2);
        }

        /* Bootstrap overrides */
        .card {
            background: rgba(74, 25, 66, 0.4);
            border-color: var(--secondary-pink);
            color: var(--soft-cream);
        }

        .card-header {
            background: rgba(74, 25, 66, 0.6) !important;
            border-color: var(--secondary-pink);
            color: var(--accent-rose) !important;
        }

        .alert {
            background: rgba(74, 25, 66, 0.5);
            border-color: var(--accent-rose);
            color: var(--soft-cream);
        }

        .alert-success { background: rgba(74, 25, 66, 0.6); border-color: var(--accent-rose); }
        .alert-warning { background: rgba(212, 80, 107, 0.3); border-color: var(--secondary-pink); }
        .alert-info { background: rgba(74, 25, 66, 0.5); border-color: var(--accent-rose); }

        /* Playing card style */
        .game-card {
            width: 120px;
            height: 180px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .game-card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 12px 24px rgba(212, 80, 107, 0.4);
        }

        .game-card.selected {
            transform: translateY(-12px);
            box-shadow: 0 16px 32px rgba(232, 118, 143, 0.6);
        }

        /* Card backgrounds by type */
        .card-position {
            background: linear-gradient(135deg, #5a2d6b 0%, #3d1f4a 100%);
            border: 2px solid #8b4a9e !important;
        }

        .card-intensity {
            background: linear-gradient(135deg, #d4506b 0%, #a83d55 100%);
            border: 2px solid #e8768f !important;
        }

        .card-time {
            background: linear-gradient(135deg, #6b3d5a 0%, #4a2d3d 100%);
            border: 2px solid #9e6b8b !important;
        }

        .card-special {
            background: linear-gradient(135deg, #d4a56b 0%, #a8835d 100%);
            border: 2px solid #e8c18f !important;
        }

        .card-pleasure {
            background: linear-gradient(135deg, #e8768f 0%, #d4506b 100%);
            border: 2px solid #ff9eb5 !important;
        }

        .card-body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.5rem;
            position: relative;
        }

        .card-indicator {
            position: absolute;
            top: 6px;
            right: 6px;
            font-size: 1.2rem;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .card-emoji {
            font-size: 2.5rem;
            margin-bottom: 0.3rem;
        }

        .card-type {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: white;
            font-weight: 600;
        }

        .card-name {
            font-size: 0.8rem;
            font-weight: 700;
            margin: 0.3rem 0;
            line-height: 1.1;
            color: white;
        }

        .card-description {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.2;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--secondary-pink), var(--primary-purple));
            border: none;
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, var(--accent-rose), var(--secondary-pink));
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 80, 107, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #8b4a9e, #6b3d7a);
            border: none;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #9e6b8b, #8b4a9e);
        }

        .btn-danger {
            background: linear-gradient(135deg, #a83d55, #7a2d3d);
            border: none;
        }

        .btn-info {
            background: linear-gradient(135deg, #d4a56b, #a8835d);
            border: none;
        }

        .log-container {
            max-height: 200px;
            overflow-y: auto;
        }

        .border-start {
            border-color: var(--accent-rose) !important;
        }

        .bg-light {
            background: rgba(255, 245, 247, 0.1) !important;
        }

        .text-muted {
            color: rgba(255, 245, 247, 0.6) !important;
        }

        h1, h5 {
            color: var(--accent-rose);
            text-shadow: 0 2px 8px rgba(212, 80, 107, 0.3);
        }

        .badge {
            padding: 0.5rem 0.75rem;
        }

        .modal-content {
            background: var(--primary-purple);
            color: var(--soft-cream);
            border: 2px solid var(--secondary-pink);
        }

        .modal-header {
            border-color: var(--secondary-pink);
        }

        .modal-footer {
            border-color: var(--secondary-pink);
        }

        /* Toast notification */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--secondary-pink), var(--primary-purple));
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(212, 80, 107, 0.4);
            z-index: 9999;
            animation: slideIn 0.3s ease-out;
            font-weight: 500;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="cards.js"></script>
</head>
<body>
    <div id="root"></div>

    <script>
        const { useState, useEffect, useRef } = React;

        // Import card data
        const { GAME_CARDS, getAllMainDeckCards, shuffleDeck } = window;

        function App() {
            const [logs, setLogs] = useState([]);
            const [status, setStatus] = useState('initializing');
            const [isPlayer1, setIsPlayer1] = useState(false);
            const [gameLink, setGameLink] = useState('');
            const [connected, setConnected] = useState(false);

            // Game state
            const [gameState, setGameState] = useState(null);
            const [selectedCards, setSelectedCards] = useState([]);
            const [winner, setWinner] = useState(null);
            const [sessionId, setSessionId] = useState(null);
            const [showAskDialog, setShowAskDialog] = useState(false);
            const [askingCardType, setAskingCardType] = useState(null);
            const [logsCollapsed, setLogsCollapsed] = useState(true);
            const [toast, setToast] = useState(null);

            const peerRef = useRef(null);
            const connRef = useRef(null);
            const qrRef = useRef(null);

            const addLog = (message) => {
                const time = new Date().toLocaleTimeString();
                setLogs(prev => [...prev, { time, message }]);
            };

            // Get or create unique device ID
            const getDeviceId = () => {
                let deviceId = localStorage.getItem('deviceId');
                if (!deviceId) {
                    deviceId = 'device_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                    localStorage.setItem('deviceId', deviceId);
                    console.log('[SESSION] Created new device ID:', deviceId);
                } else {
                    console.log('[SESSION] Existing device ID:', deviceId);
                }
                return deviceId;
            };

            // Save session to localStorage with device ID
            const saveSession = (peerId, isP1, gState) => {
                const deviceId = getDeviceId();
                const session = {
                    deviceId,
                    peerId,
                    isPlayer1: isP1,
                    gameState: gState,
                    timestamp: Date.now()
                };
                localStorage.setItem('gameSession', JSON.stringify(session));
                setSessionId(peerId);
                console.log('[SESSION] Saved:', {
                    deviceId,
                    peerId,
                    isPlayer1: isP1,
                    hasGameState: !!gState,
                    queueLength: gState?.queue?.length || 0,
                    timestamp: new Date(session.timestamp).toLocaleTimeString()
                });
                addLog(`üíæ Session saved (P${isP1 ? '1' : '2'}, Queue: ${gState?.queue?.length || 0})`);
            };

            // Load session from localStorage
            const loadSession = () => {
                console.log('[SESSION] Loading session from localStorage...');
                const saved = localStorage.getItem('gameSession');
                if (!saved) {
                    console.log('[SESSION] No saved session found');
                    addLog('üìÇ No previous session found');
                    return null;
                }

                const session = JSON.parse(saved);
                const currentDeviceId = getDeviceId();
                console.log('[SESSION] Found session:', {
                    savedDeviceId: session.deviceId,
                    currentDeviceId,
                    match: session.deviceId === currentDeviceId,
                    peerId: session.peerId,
                    isPlayer1: session.isPlayer1,
                    hasGameState: !!session.gameState,
                    queueLength: session.gameState?.queue?.length || 0,
                    savedAt: new Date(session.timestamp).toLocaleString()
                });

                // Check if this is the same device
                if (session.deviceId !== currentDeviceId) {
                    console.warn('[SESSION] Device mismatch - clearing session');
                    addLog('‚ö†Ô∏è Different device detected, clearing session');
                    localStorage.removeItem('gameSession');
                    return null;
                }

                // Session expires after 24 hours
                const age = Date.now() - session.timestamp;
                const ageHours = (age / (1000 * 60 * 60)).toFixed(1);
                console.log('[SESSION] Session age:', ageHours, 'hours');

                if (age < 24 * 60 * 60 * 1000) {
                    addLog(`‚úÖ Loaded session (${ageHours}h old, Queue: ${session.gameState?.queue?.length || 0})`);
                    return session;
                }

                console.warn('[SESSION] Session expired - clearing');
                addLog('‚è∞ Session expired (>24h old)');
                localStorage.removeItem('gameSession');
                return null;
            };

            // Clear session
            const clearSession = () => {
                console.log('[SESSION] Clearing session and starting new game');
                addLog('üîÑ Starting new game...');
                localStorage.removeItem('gameSession');
                setSessionId(null);
                setTimeout(() => {
                    window.location.href = window.location.pathname;
                }, 500);
            };

            // Initialize game state
            const initializeGame = (asPlayer1) => {
                const mainDeck = shuffleDeck(getAllMainDeckCards());
                const equipmentDeck = shuffleDeck([...GAME_CARDS.equipmentDeck]);
                const pleasureDeck = shuffleDeck([...GAME_CARDS.pleasureDeck]);

                const state = {
                    mainDeck,
                    equipmentDeck,
                    pleasureDeck,
                    player1: {
                        hand: mainDeck.splice(0, 5),
                        points: 0,
                    },
                    player2: {
                        hand: mainDeck.splice(0, 5),
                        pleasureCards: [],
                    },
                    queue: [],
                    currentTurn: 1, // 1 or 2
                    discardPile: [],
                };

                return state;
            };

            useEffect(() => {
                console.log('[INIT] Starting initialization...');
                const urlParams = new URLSearchParams(window.location.search);
                let peerId = urlParams.get('peer');
                console.log('[INIT] URL peer ID:', peerId || '(none)');

                // Try to load saved session
                const savedSession = loadSession();

                // If no peer ID in URL but we have a saved session for Player 2, restore it
                if (!peerId && savedSession && !savedSession.isPlayer1 && savedSession.peerId) {
                    console.log('[INIT] Player 2 refresh detected - restoring URL');
                    peerId = savedSession.peerId;
                    // Redirect to the proper URL with peer ID
                    window.history.replaceState({}, '', `${window.location.pathname}?peer=${peerId}`);
                    addLog('üîÑ Restoring Player 2 session...');
                }

                if (!peerId) {
                    // Player 1: Create peer and wait for connection
                    console.log('[INIT] No peer ID in URL - initializing as Player 1');
                    setIsPlayer1(true);

                    // Try to reuse the same peer ID from saved session
                    let savedPeerId = null;
                    if (savedSession && savedSession.isPlayer1 && savedSession.peerId) {
                        savedPeerId = savedSession.peerId;
                        console.log('[INIT] Attempting to reuse Player 1 peer ID:', savedPeerId);
                        addLog(`üîÑ Restoring Player 1 session (ID: ${savedPeerId.substring(0, 8)}...)`);
                        if (savedSession.gameState) {
                            console.log('[INIT] Restoring game state for Player 1');
                            setGameState(savedSession.gameState);
                            addLog(`‚úÖ Game state restored (Queue: ${savedSession.gameState.queue.length})`);
                        }
                    } else {
                        console.log('[INIT] No saved session - creating new Player 1');
                        addLog('üÜï Initializing as Player 1...');
                    }

                    const peer = new Peer(savedPeerId, {
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', (id) => {
                        console.log('[PEER] Player 1 peer opened with ID:', id);
                        addLog(`‚úÖ Peer created with ID: ${id.substring(0, 8)}...`);
                        const link = `${window.location.origin}${window.location.pathname}?peer=${id}`;
                        setGameLink(link);
                        setStatus('waiting');
                        setSessionId(id);

                        if (savedPeerId && id === savedPeerId) {
                            console.log('[PEER] Successfully reused peer ID');
                            addLog('‚úÖ Session restored with same peer ID');
                        } else if (savedPeerId) {
                            console.warn('[PEER] Peer ID changed! Old:', savedPeerId, 'New:', id);
                            addLog('‚ö†Ô∏è New peer ID assigned (old one unavailable)');
                        }

                        addLog('‚è≥ Waiting for Player 2 to connect...');
                        addLog('üì§ Share the link below to invite them!');

                        // Generate QR code
                        setTimeout(() => {
                            if (qrRef.current && window.QRCode) {
                                qrRef.current.innerHTML = '';
                                new QRCode(qrRef.current, {
                                    text: link,
                                    width: 200,
                                    height: 200,
                                    colorDark: '#000000',
                                    colorLight: '#ffffff',
                                    correctLevel: QRCode.CorrectLevel.M
                                });
                            }
                        }, 100);
                    });

                    peer.on('connection', (conn) => {
                        console.log('[PEER] Player 2 is connecting...');
                        addLog('üîó Player 2 is connecting...');
                        connRef.current = conn;
                        setupConnection(conn, true);
                    });

                    peer.on('error', (err) => {
                        console.error('[PEER] Error:', err.type, err.message);
                        addLog(`‚ùå Error: ${err.message}`);
                        // If peer ID is already taken, try with a new one
                        if (err.type === 'unavailable-id' || err.type === 'invalid-id') {
                            console.warn('[PEER] Peer ID unavailable, clearing session and reloading');
                            addLog('‚ö†Ô∏è Peer ID unavailable, creating new session...');
                            localStorage.removeItem('gameSession');
                            setTimeout(() => window.location.reload(), 1000);
                        }
                    });

                } else {
                    // Player 2: Connect to Player 1
                    console.log('[INIT] Peer ID in URL - initializing as Player 2');
                    setIsPlayer1(false);
                    setStatus('connecting');

                    // Restore game state if exists
                    if (savedSession && !savedSession.isPlayer1 && savedSession.gameState) {
                        console.log('[INIT] Restoring game state for Player 2');
                        addLog(`üîÑ Restoring Player 2 session (Queue: ${savedSession.gameState.queue.length})`);
                        setGameState(savedSession.gameState);
                    } else {
                        console.log('[INIT] No saved session for Player 2 - connecting fresh');
                        addLog('üÜï Initializing as Player 2...');
                    }

                    // Save peer ID for reconnection
                    console.log('[INIT] Saving Player 2 peer ID:', peerId);
                    saveSession(peerId, false, savedSession?.gameState || null);
                    setSessionId(peerId);

                    const peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', () => {
                        console.log('[PEER] Player 2 peer initialized');
                        addLog('‚úÖ Peer initialized');
                        addLog(`üîó Connecting to Player 1 (ID: ${peerId.substring(0, 8)}...)...`);

                        const conn = peer.connect(peerId, {
                            reliable: true
                        });

                        console.log('[PEER] Player 2 attempting connection to Player 1');
                        connRef.current = conn;
                        setupConnection(conn, false);
                    });

                    peer.on('error', (err) => {
                        console.error('[PEER] Player 2 error:', err.type, err.message);
                        addLog(`‚ùå Error: ${err.message}`);
                    });
                }

                return () => {
                    if (connRef.current) {
                        connRef.current.close();
                    }
                    if (peerRef.current) {
                        peerRef.current.destroy();
                    }
                };
            }, []);

            // Auto-save game state changes for BOTH players
            useEffect(() => {
                if (gameState && sessionId) {
                    console.log('[AUTO-SAVE] Saving game state change');
                    saveSession(sessionId, isPlayer1, gameState);
                }
            }, [gameState]);

            const setupConnection = (conn, asPlayer1) => {
                conn.on('open', () => {
                    console.log('[CONNECTION] Connection opened! Player:', asPlayer1 ? 1 : 2);
                    addLog('‚úÖ Connection opened!');
                    addLog('‚úÖ ICE route finding complete');
                    setStatus('connected');
                    setConnected(true);

                    if (asPlayer1) {
                        // Player 1 initializes the game or uses saved state
                        // Use a small delay to ensure React state has been updated from restoration
                        setTimeout(() => {
                            console.log('[CONNECTION] Player 1 checking for existing game state');
                            setGameState(prevState => {
                                let initialState = prevState;
                                if (!initialState) {
                                    console.log('[CONNECTION] No game state - initializing new game');
                                    initialState = initializeGame(true);
                                    addLog('üéÆ New game initialized');
                                } else {
                                    console.log('[CONNECTION] Using existing game state (Queue:', initialState.queue.length, ')');
                                    addLog(`üéÆ Resuming game (Queue: ${initialState.queue.length})`);
                                }
                                console.log('[CONNECTION] Sending game state to Player 2');
                                sendGameState(initialState);
                                // Save session
                                saveSession(peerRef.current?.id, true, initialState);
                                addLog('‚úÖ Player 1 starts.');
                                return initialState;
                            });
                        }, 100);
                    } else {
                        console.log('[CONNECTION] Player 2 waiting for game state from Player 1');
                        addLog('‚è≥ Waiting for game initialization...');
                    }
                });

                conn.on('data', (data) => {
                    handleMessage(data);
                });

                conn.on('close', () => {
                    console.log('[CONNECTION] Connection closed');
                    addLog('‚ùå Connection closed');
                    setConnected(false);
                    setStatus('disconnected');
                });

                conn.on('error', (err) => {
                    console.error('[CONNECTION] Connection error:', err.message);
                    addLog(`‚ùå Connection error: ${err.message}`);
                });
            };

            const sendGameState = (state) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'gameState',
                        state: state
                    });
                }
            };

            const sendAction = (action) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'action',
                        action: action
                    });
                }
            };

            const handleMessage = (data) => {
                console.log('[MESSAGE] Received:', data.type);
                if (data.type === 'gameState') {
                    console.log('[MESSAGE] Updating game state (Queue:', data.state.queue.length, ')');
                    setGameState(data.state);
                    // Save updated state for BOTH players
                    const peerId = isPlayer1 ? peerRef.current?.id : sessionId;
                    if (peerId) {
                        console.log('[MESSAGE] Saving received game state for', isPlayer1 ? 'P1' : 'P2');
                        saveSession(peerId, isPlayer1, data.state);
                    }
                    addLog('üì• Game state updated');
                } else if (data.type === 'action') {
                    console.log('[MESSAGE] Processing action:', data.action.type);
                    processAction(data.action);
                } else if (data.type === 'winner') {
                    console.log('[MESSAGE] Winner declared:', data.winner);
                    setWinner(data.winner === 'opponent' ? 'opponent' : 'me');
                    addLog(data.winner === 'opponent' ? 'üéâ Opponent won!' : 'üòî You won!');
                }
            };

            const processAction = (action) => {
                // Process opponent's action and update game state
                setGameState(prevState => {
                    const newState = { ...prevState };

                    switch (action.type) {
                        case 'playSet':
                            // Add set to queue
                            newState.queue.push(action.set);
                            // Update player stats
                            if (action.player === 1) {
                                newState.player1.points += 1;
                            }
                            // Switch turn
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent played a set`);
                            break;

                        case 'discard':
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent discarded a card`);
                            break;

                        case 'drawEquipment':
                            addLog(`Opponent drew equipment`);
                            break;

                        case 'drawPleasure':
                            addLog(`Opponent drew a pleasure card`);
                            break;

                        case 'drawCard':
                            addLog(`Opponent drew a card`);
                            break;

                        case 'stealCard':
                            addLog(`Opponent used Steal Card`);
                            break;

                        case 'askForCard':
                            addLog(`Opponent used Ask For Card (${action.requestedType})`);
                            break;
                    }

                    return newState;
                });
            };

            const handleCardClick = (card) => {
                if (!isMyTurn()) return;

                setSelectedCards(prev => {
                    const isSelected = prev.find(c => c.id === card.id);
                    if (isSelected) {
                        return prev.filter(c => c.id !== card.id);
                    } else {
                        return [...prev, card];
                    }
                });
            };

            const isMyTurn = () => {
                if (!gameState) return false;
                return (isPlayer1 && gameState.currentTurn === 1) ||
                       (!isPlayer1 && gameState.currentTurn === 2);
            };

            const canPlaySet = () => {
                if (selectedCards.length !== 3) return false;
                const hasPosition = selectedCards.some(c => c.type === 'position');
                const hasIntensity = selectedCards.some(c => c.type === 'intensity');
                const hasTime = selectedCards.some(c => c.type === 'time');
                return hasPosition && hasIntensity && hasTime;
            };

            const handleDrawCard = () => {
                if (!isMyTurn() || !gameState) return;

                const playerKey = isPlayer1 ? 'player1' : 'player2';
                const currentHand = gameState[playerKey].hand;

                // Can only draw if hand has less than 5 cards
                if (currentHand.length >= 5) {
                    addLog('‚ö†Ô∏è Cannot draw - hand is full (max 5 cards)');
                    return;
                }

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    if (newState.mainDeck.length > 0) {
                        const drawnCard = newState.mainDeck.shift();
                        newState[playerKey].hand.push(drawnCard);
                        addLog(`Drew: ${drawnCard.name}`);
                    }

                    // Switch turn after drawing
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    // Send state after update
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                const action = {
                    type: 'drawCard'
                };
                sendAction(action);
            };

            const handlePlaySet = () => {
                if (!canPlaySet() || !gameState) return;

                const position = selectedCards.find(c => c.type === 'position');
                const intensity = selectedCards.find(c => c.type === 'intensity');
                const time = selectedCards.find(c => c.type === 'time');

                const set = {
                    position,
                    intensity,
                    time,
                    equipment: []
                };

                let updatedState;

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove cards from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => !selectedCards.find(sc => sc.id === c.id)
                    );

                    // Update player stats
                    if (isPlayer1) {
                        // Player 1: Add to queue and get points
                        newState.queue.push(set);
                        newState.player1.points += 1;
                    } else {
                        // Player 2: Draw pleasure card (NOT added to queue)
                        if (newState.pleasureDeck.length > 0) {
                            const pleasureCard = newState.pleasureDeck.shift();
                            newState.player2.pleasureCards.push(pleasureCard);
                            addLog(`Drew pleasure: ${pleasureCard.name}`);
                        }
                    }

                    // Check win conditions
                    let hasWon = false;
                    if (newState.queue.length >= 5 && isPlayer1) {
                        hasWon = true;
                    } else if (newState.player2.pleasureCards.length >= 5 && !isPlayer1) {
                        hasWon = true;
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    addLog(`Played set: ${position.name} + ${intensity.name} + ${time.name}`);

                    // Notify about win
                    if (hasWon) {
                        setWinner('me');
                        setTimeout(() => {
                            if (connRef.current && connRef.current.open) {
                                connRef.current.send({
                                    type: 'winner',
                                    winner: 'opponent'
                                });
                            }
                        }, 100);
                    }

                    // Store updated state for sending
                    updatedState = newState;

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'playSet',
                    player: isPlayer1 ? 1 : 2,
                    set
                };
                sendAction(action);

                // Send the updated state
                setTimeout(() => {
                    if (connRef.current && connRef.current.open && updatedState) {
                        sendGameState(updatedState);
                    }
                }, 50);
            };

            const handleDiscard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || !gameState) return;

                const discardedCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== discardedCard.id
                    );

                    // Add to discard pile
                    newState.discardPile.push(discardedCard);

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    addLog(`Discarded: ${discardedCard.name}`);

                    // Send updated state
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'discard'
                };
                sendAction(action);
            };

            const handleDrawEquipment = () => {
                if (!isPlayer1 || !isMyTurn() || !gameState || gameState.player1.points < 1) return;

                setGameState(prev => {
                    const newState = { ...prev };

                    if (newState.equipmentDeck.length > 0 && newState.queue.length > 0) {
                        const equipment = newState.equipmentDeck.shift();
                        newState.queue[newState.queue.length - 1].equipment.push(equipment);
                        newState.player1.points -= 1;
                        addLog(`Added equipment: ${equipment.name}`);

                        // Send updated state
                        setTimeout(() => {
                            sendGameState(newState);
                        }, 50);
                    }

                    return newState;
                });

                const action = {
                    type: 'drawEquipment'
                };
                sendAction(action);
            };

            // Handle playing a special card (Steal Card)
            const handleStealCard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || selectedCards[0].type !== 'special' || selectedCards[0].action !== 'steal') return;

                const specialCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';
                    const opponentKey = isPlayer1 ? 'player2' : 'player1';

                    // Remove special card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== specialCard.id
                    );

                    // Discard the special card
                    newState.discardPile.push(specialCard);

                    // Steal random card from opponent if they have any
                    if (newState[opponentKey].hand.length > 0) {
                        const randomIndex = Math.floor(Math.random() * newState[opponentKey].hand.length);
                        const stolenCard = newState[opponentKey].hand.splice(randomIndex, 1)[0];
                        newState[playerKey].hand.push(stolenCard);
                        addLog(`Stole ${stolenCard.name} from opponent!`);
                    } else {
                        addLog('Opponent has no cards to steal');
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'stealCard',
                    cardId: specialCard.id
                };
                sendAction(action);
            };

            // Handle "Ask For Card" - show dialog
            const handleAskForCard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || selectedCards[0].type !== 'special' || selectedCards[0].action !== 'ask') return;
                setShowAskDialog(true);
            };

            // Execute ask for card with selected type
            const executeAskForCard = (cardType) => {
                if (!cardType) return;

                const specialCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';
                    const opponentKey = isPlayer1 ? 'player2' : 'player1';

                    // Remove special card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== specialCard.id
                    );

                    // Discard the special card
                    newState.discardPile.push(specialCard);

                    // Find card of requested type from opponent
                    const requestedCard = newState[opponentKey].hand.find(c => c.type === cardType);
                    if (requestedCard) {
                        newState[opponentKey].hand = newState[opponentKey].hand.filter(c => c.id !== requestedCard.id);
                        newState[playerKey].hand.push(requestedCard);
                        addLog(`Received ${requestedCard.name} from opponent!`);
                    } else {
                        addLog(`Opponent doesn't have a ${cardType} card`);
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);
                setShowAskDialog(false);

                const action = {
                    type: 'askForCard',
                    cardId: specialCard.id,
                    requestedType: cardType
                };
                sendAction(action);
            };

            const showToast = (message) => {
                setToast(message);
                setTimeout(() => setToast(null), 3000);
            };

            const copyLink = async () => {
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(gameLink);
                        showToast('‚úÖ Link copied to clipboard!');
                        addLog('Link copied to clipboard!');
                    } else {
                        const textarea = document.createElement('textarea');
                        textarea.value = gameLink;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        showToast('‚úÖ Link copied to clipboard!');
                        addLog('Link copied to clipboard!');
                    }
                } catch (err) {
                    showToast('‚ùå Failed to copy link');
                    addLog('Failed to copy link');
                }
            };

            const shareLink = async () => {
                if (navigator.share) {
                    try {
                        await navigator.share({
                            title: 'The GAME',
                            text: 'Join me in a card game!',
                            url: gameLink
                        });
                        addLog('Link shared!');
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            addLog('Share failed, use copy instead');
                        }
                    }
                } else {
                    copyLink();
                }
            };

            const myHand = gameState && (isPlayer1 ? gameState.player1.hand : gameState.player2.hand);
            const myStats = gameState && (isPlayer1 ? gameState.player1 : gameState.player2);

            return React.createElement('div', { className: 'container my-4' },
                toast && React.createElement('div', { className: 'toast-notification' }, toast),

                React.createElement('h1', { className: 'text-center mb-4' }, 'üé¥ The GAME'),

                !connected && React.createElement('div', {
                    className: 'alert alert-danger text-center mb-3 py-2',
                    style: { borderColor: 'var(--secondary-pink)', color: 'white' }
                },
                    React.createElement('strong', null, 'üîû 18+ Adult Content ‚Ä¢ '),
                    React.createElement('span', { className: 'small' },
                        'Intimate P2P card game for couples exploring consensual discipline & pleasure'
                    )
                ),

                !connected && isPlayer1 && gameLink && React.createElement('div', null,
                    React.createElement('div', { className: 'border rounded p-4 mb-3 bg-light text-center' },
                        React.createElement('div', {
                            className: 'bg-white p-3 rounded d-inline-block mb-3',
                            ref: qrRef
                        }),
                        React.createElement('div', { className: 'text-muted small' }, 'üì± Share this QR code or link with your partner')
                    ),
                    React.createElement('button', {
                        className: 'btn btn-primary w-100 mb-3',
                        onClick: copyLink
                    }, `üìã Copy Link: ${gameLink.substring(0, 15)}...`)
                ),

                !connected && !isPlayer1 && React.createElement('div', { className: 'alert alert-info' },
                    React.createElement('strong', null, 'üîó Connecting to Player 1...'),
                    React.createElement('p', { className: 'mt-2 mb-0' },
                        'This may take 5-10 seconds while finding the best route...'
                    )
                ),

                connected && gameState && React.createElement('div', { className: 'vstack gap-3' },
                    winner && React.createElement('div', {
                        className: `alert text-center fs-4 fw-bold ${winner === 'me' ? 'alert-success' : 'alert-danger'}`
                    },
                        winner === 'me' ? 'üéâ You Won!' : 'üòî You Lost!'
                    ),

                    React.createElement('div', { className: 'card' },
                        React.createElement('div', { className: 'card-body d-flex justify-content-between align-items-center flex-wrap gap-3' },
                        React.createElement('div', null,
                            React.createElement('div', { className: 'fs-5 fw-bold text-primary' },
                                isPlayer1 ? 'üë§ Player 1' : 'üë§ Player 2'
                            ),
                            React.createElement('div', {
                                className: `fw-semibold ${isMyTurn() ? 'text-success' : 'text-muted'}`
                            },
                                isMyTurn() ? '‚úì Your Turn' : '‚è≥ Opponent\'s Turn'
                            )
                        ),
                        React.createElement('div', { className: 'd-flex gap-3 align-items-center flex-wrap' },
                        React.createElement('div', { className: 'd-flex gap-4' },
                            React.createElement('div', null,
                                React.createElement('div', { className: 'text-muted small' }, 'Points (P1:P2)'),
                                React.createElement('div', { className: 'fs-4 fw-bold' },
                                    isPlayer1
                                        ? React.createElement('span', null,
                                            React.createElement('span', { className: 'text-primary fs-3' }, gameState?.player1?.points || 0),
                                            ':',
                                            gameState?.player2?.pleasureCards?.length || 0
                                        )
                                        : React.createElement('span', null,
                                            gameState?.player1?.points || 0,
                                            ':',
                                            React.createElement('span', { className: 'text-primary fs-3' }, gameState?.player2?.pleasureCards?.length || 0)
                                        )
                                )
                            ),
                            React.createElement('div', null,
                                React.createElement('div', { className: 'text-muted small' }, 'Your Hand'),
                                React.createElement('div', { className: 'fs-4 fw-bold' }, myHand.length)
                            ),
                            React.createElement('div', null,
                                React.createElement('div', { className: 'text-muted small' }, 'Opponent Hand'),
                                React.createElement('div', { className: 'fs-4 fw-bold' }, isPlayer1 ? gameState.player2.hand.length : gameState.player1.hand.length)
                            )
                        ),
                        isPlayer1 && React.createElement('button', {
                            className: 'btn btn-outline-danger btn-sm',
                            onClick: clearSession
                        }, 'üîÑ New Game')
                    )
                    )
                    ),

                    React.createElement('div', { className: 'card' },
                        React.createElement('div', { className: 'card-header bg-light' },
                            React.createElement('h5', { className: 'mb-0' }, 'üé¥ Your Hand')
                        ),
                        React.createElement('div', { className: 'card-body' },
                            React.createElement('div', { className: 'd-flex gap-3 flex-wrap' },
                                [...myHand].sort((a, b) => {
                                    // Sort by type first, then by name
                                    const typeOrder = { position: 1, intensity: 2, time: 3, special: 4 };
                                    const typeCompare = (typeOrder[a.type] || 5) - (typeOrder[b.type] || 5);
                                    if (typeCompare !== 0) return typeCompare;
                                    return a.name.localeCompare(b.name);
                                }).map(card => {
                                    // Determine indicator emoji based on card type
                                    let indicator = '';
                                    if (card.type === 'position') indicator = '1Ô∏è‚É£';
                                    else if (card.type === 'intensity') indicator = '2Ô∏è‚É£';
                                    else if (card.type === 'time') indicator = '3Ô∏è‚É£';
                                    else if (card.type === 'special') indicator = '‚ú®';

                                    return React.createElement('div', {
                                        className: `game-card card-${card.type} ${selectedCards.find(c => c.id === card.id) ? 'selected' : ''}`,
                                        key: card.id,
                                        onClick: () => handleCardClick(card)
                                    },
                                        React.createElement('div', { className: 'card-body' },
                                            card.emoji && React.createElement('div', { className: 'card-emoji' }, card.emoji),
                                            React.createElement('div', { className: 'card-type' }, card.type),
                                            React.createElement('div', { className: 'card-name' }, card.name),
                                            card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                            card.duration !== undefined && React.createElement('div', { className: 'card-description' },
                                                `${card.duration}s`
                                            ),
                                            React.createElement('div', { className: 'card-indicator' }, indicator)
                                        )
                                    );
                                })
                            )
                        )
                    ),

                    React.createElement('div', { className: 'd-flex gap-2 flex-wrap' },
                        myHand.length < 5 && isMyTurn() && selectedCards.length === 0 && React.createElement('button', {
                            className: 'btn btn-primary btn-lg',
                            onClick: handleDrawCard
                        }, 'üì• Draw Card (end turn)'),
                        canPlaySet() && React.createElement('button', {
                            className: 'btn btn-success btn-lg',
                            onClick: handlePlaySet
                        }, '‚úÖ Play Set (3 cards)'),
                        myHand.length >= 5 && isMyTurn() && selectedCards.length === 1 && selectedCards[0]?.type !== 'special' && React.createElement('button', {
                            className: 'btn btn-danger btn-lg',
                            onClick: handleDiscard
                        }, 'üóëÔ∏è Discard (end turn)'),
                        isMyTurn() && selectedCards.length === 1 && selectedCards[0]?.type === 'special' && selectedCards[0]?.action === 'steal' && React.createElement('button', {
                            className: 'btn btn-info btn-lg',
                            onClick: handleStealCard
                        }, 'üÉè Steal Card'),
                        isMyTurn() && selectedCards.length === 1 && selectedCards[0]?.type === 'special' && selectedCards[0]?.action === 'ask' && React.createElement('button', {
                            className: 'btn btn-info btn-lg',
                            onClick: handleAskForCard
                        }, '‚ùì Ask For Card'),
                        isPlayer1 && isMyTurn() && myStats.points >= 1 && gameState?.queue?.length > 0 && React.createElement('button', {
                            className: 'btn btn-warning btn-lg',
                            onClick: handleDrawEquipment
                        }, 'üîß Add Equipment (1pt)')
                    ),

                    showAskDialog && React.createElement('div', {
                        className: 'modal show d-block',
                        style: { backgroundColor: 'rgba(0,0,0,0.5)' },
                        onClick: () => setShowAskDialog(false)
                    },
                        React.createElement('div', {
                            className: 'modal-dialog modal-dialog-centered',
                            onClick: (e) => e.stopPropagation()
                        },
                            React.createElement('div', { className: 'modal-content' },
                                React.createElement('div', { className: 'modal-header' },
                                    React.createElement('h5', { className: 'modal-title' }, '‚ùì Ask For Card Type'),
                                    React.createElement('button', {
                                        type: 'button',
                                        className: 'btn-close',
                                        onClick: () => setShowAskDialog(false)
                                    })
                                ),
                                React.createElement('div', { className: 'modal-body' },
                                    React.createElement('p', null, 'Choose which type of card to request from your opponent:'),
                                    React.createElement('div', { className: 'd-grid gap-2' },
                                        React.createElement('button', {
                                            className: 'btn btn-primary',
                                            onClick: () => executeAskForCard('position')
                                        }, 'üìç Position Card'),
                                        React.createElement('button', {
                                            className: 'btn btn-danger',
                                            onClick: () => executeAskForCard('intensity')
                                        }, 'üí™ Intensity Card'),
                                        React.createElement('button', {
                                            className: 'btn btn-success',
                                            onClick: () => executeAskForCard('time')
                                        }, '‚è±Ô∏è Time Card'),
                                        React.createElement('button', {
                                            className: 'btn btn-warning',
                                            onClick: () => executeAskForCard('special')
                                        }, '‚ú® Special Card')
                                    )
                                ),
                                React.createElement('div', { className: 'modal-footer' },
                                    React.createElement('button', {
                                        className: 'btn btn-secondary',
                                        onClick: () => setShowAskDialog(false)
                                    }, 'Cancel')
                                )
                            )
                        )
                    )
                ),

                connected && gameState && React.createElement('div', { className: 'alert alert-warning mt-4' },
                    React.createElement('div', { className: 'fs-5 fw-bold mb-3', style: { color: 'white' } },
                        `üî• Spanking Queue (${gameState?.queue?.length || 0}/5)`
                    ),
                    (!gameState?.queue || gameState.queue.length === 0) && React.createElement('div', {
                        className: 'fst-italic',
                        style: { color: 'rgba(255, 255, 255, 0.8)' }
                    }, 'No punishments queued yet'),
                    React.createElement('div', { className: 'vstack gap-2' },
                        (gameState?.queue || []).map((item, idx) =>
                            React.createElement('div', { className: 'card border-warning', key: idx },
                                React.createElement('div', { className: 'card-body p-3' },
                                React.createElement('div', { className: 'd-flex gap-2 flex-wrap mb-2' },
                                    React.createElement('div', { className: 'text-center' },
                                        React.createElement('span', { className: 'badge bg-primary d-block mb-1' }, item.position.name),
                                        React.createElement('div', { style: { fontSize: '1.5rem' } }, item.position.emoji || 'üìç')
                                    ),
                                    React.createElement('div', { className: 'text-center' },
                                        React.createElement('span', { className: 'badge bg-danger d-block mb-1' }, item.intensity.name),
                                        React.createElement('div', { style: { fontSize: '1.5rem' } }, item.intensity.emoji || 'üí™')
                                    ),
                                    React.createElement('div', { className: 'text-center' },
                                        React.createElement('span', { className: 'badge bg-success d-block mb-1' }, item.time.name),
                                        React.createElement('div', { style: { fontSize: '1.5rem' } }, item.time.emoji || '‚è±Ô∏è')
                                    )
                                ),
                                item.equipment && item.equipment.length > 0 &&
                                React.createElement('div', { className: 'd-flex gap-2 flex-wrap pt-2 border-top' },
                                    item.equipment.map((eq, eqIdx) =>
                                        React.createElement('span', { className: 'badge bg-danger-subtle text-danger-emphasis', key: eqIdx }, eq.name)
                                    )
                                )
                            )
                            )
                        )
                    )
                ),

                (isPlayer1 ? gameState?.player2?.pleasureCards?.length > 0 : myStats?.pleasureCards?.length > 0) && React.createElement('div', { className: 'card' },
                    React.createElement('div', { className: 'card-header' },
                        React.createElement('h5', { className: 'mb-0' }, isPlayer1 ? 'üíù Player 2 Pleasure Cards' : 'üíù Your Pleasure Cards')
                    ),
                    React.createElement('div', { className: 'card-body' },
                        React.createElement('div', { className: 'd-flex gap-3 flex-wrap' },
                            (isPlayer1 ? gameState.player2.pleasureCards : myStats.pleasureCards).map((card, idx) =>
                                React.createElement('div', {
                                    className: 'game-card card-pleasure',
                                    key: idx
                                },
                                    React.createElement('div', { className: 'card-body' },
                                        card.emoji && React.createElement('div', { className: 'card-emoji' }, card.emoji),
                                        React.createElement('div', { className: 'card-type' }, 'pleasure'),
                                        React.createElement('div', { className: 'card-name' }, card.name),
                                        card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                        card.duration && React.createElement('div', { className: 'card-description' }, card.duration)
                                    )
                                )
                            )
                        )
                    )
                ),

                React.createElement('div', { className: 'card mb-3 mt-4' },
                    React.createElement('div', {
                        className: 'card-header bg-light d-flex justify-content-between align-items-center',
                        style: { cursor: 'pointer' },
                        onClick: () => setLogsCollapsed(!logsCollapsed)
                    },
                        React.createElement('strong', null,
                            status === 'waiting' ? 'üìã Activity Log - ‚è≥ Waiting for Player 2...' :
                            status === 'connecting' ? 'üìã Activity Log - üîÑ Connecting...' :
                            status === 'connected' ? 'üìã Activity Log - ‚úÖ Connected!' :
                            'üìã Activity Log - üîß Initializing...'
                        ),
                        React.createElement('span', { className: 'badge bg-secondary' }, logsCollapsed ? '‚ñº Show' : '‚ñ≤ Hide')
                    ),
                    !logsCollapsed && React.createElement('div', { className: 'card-body p-0' },
                        React.createElement('div', { className: 'log-container p-3' },
                            logs.length === 0 ?
                                React.createElement('div', { className: 'text-muted fst-italic small' }, 'No activity yet') :
                                logs.map((log, i) =>
                                    React.createElement('div', { className: 'border-start border-primary border-3 bg-light rounded p-2 mb-1 small', key: i },
                                        React.createElement('span', { className: 'text-muted me-2 small' }, log.time),
                                        React.createElement('span', null, log.message)
                                    )
                                )
                        )
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
