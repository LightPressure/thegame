<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The GAME - P2P Card Game</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* Romantic/Sensual Theme */
        :root {
            --primary-dark: #1a0d1f;
            --primary-purple: #4a1942;
            --secondary-pink: #d4506b;
            --accent-rose: #e8768f;
            --soft-cream: #fff5f7;
            --card-bg: linear-gradient(135deg, #2d1537 0%, #1f0e29 100%);
        }

        body {
            background: linear-gradient(135deg, #1a0d1f 0%, #2d1537 50%, #1a0d1f 100%);
            min-height: 100vh;
            color: var(--soft-cream);
            position: relative;
            overflow-x: hidden;
        }

        /* Sparkle effects */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                radial-gradient(2px 2px at 20% 30%, rgba(232, 118, 143, 0.4), transparent),
                radial-gradient(2px 2px at 60% 70%, rgba(212, 80, 107, 0.3), transparent),
                radial-gradient(1px 1px at 50% 50%, rgba(255, 255, 255, 0.3), transparent),
                radial-gradient(2px 2px at 80% 10%, rgba(232, 118, 143, 0.4), transparent),
                radial-gradient(1px 1px at 90% 60%, rgba(255, 255, 255, 0.2), transparent),
                radial-gradient(2px 2px at 30% 80%, rgba(212, 80, 107, 0.3), transparent),
                radial-gradient(1px 1px at 15% 90%, rgba(232, 118, 143, 0.4), transparent);
            background-size: 200% 200%;
            background-position: 0% 0%;
            animation: sparkle 20s ease-in-out infinite;
            pointer-events: none;
            z-index: 0;
        }

        /* Countdown Timer Modal */
        .countdown-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .countdown-container {
            text-align: center;
            padding: 3rem;
            background: linear-gradient(135deg, var(--primary-purple), var(--primary-dark));
            border: 3px solid var(--secondary-pink);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(212, 80, 107, 0.5);
            min-width: 400px;
        }

        .countdown-title {
            font-size: 2rem;
            font-weight: bold;
            color: var(--accent-rose);
            margin-bottom: 1rem;
            text-shadow: 0 2px 10px rgba(212, 80, 107, 0.5);
        }

        .countdown-card {
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(74, 25, 66, 0.4);
            border: 2px solid var(--accent-rose);
            border-radius: 15px;
        }

        .countdown-time {
            font-size: 8rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 4px 20px rgba(232, 118, 143, 0.6);
            line-height: 1;
            margin: 2rem 0;
            font-variant-numeric: tabular-nums;
        }

        .countdown-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }

        @keyframes sparkle {
            0%, 100% {
                opacity: 0.3;
                background-position: 0% 0%;
            }
            50% {
                opacity: 0.6;
                background-position: 100% 100%;
            }
        }

        .container {
            position: relative;
            z-index: 1;
        }

        .container {
            background: rgba(42, 21, 50, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(212, 80, 107, 0.2);
        }

        /* Bootstrap overrides */
        .card {
            background: rgba(74, 25, 66, 0.4);
            border-color: var(--secondary-pink);
            color: var(--soft-cream);
        }

        .card-header {
            background: rgba(74, 25, 66, 0.6) !important;
            border-color: var(--secondary-pink);
            color: var(--accent-rose) !important;
        }

        .alert {
            background: rgba(74, 25, 66, 0.5);
            border-color: var(--accent-rose);
            color: var(--soft-cream);
        }

        .alert-success { background: rgba(74, 25, 66, 0.6); border-color: var(--accent-rose); }
        .alert-warning { background: rgba(212, 80, 107, 0.3); border-color: var(--secondary-pink); }
        .alert-info { background: rgba(74, 25, 66, 0.5); border-color: var(--accent-rose); }

        /* Playing card style */
        .game-card {
            width: 120px;
            height: 180px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .game-card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 12px 24px rgba(212, 80, 107, 0.4);
        }

        .game-card.selected {
            transform: translateY(-12px);
            box-shadow: 0 16px 32px rgba(232, 118, 143, 0.6);
        }

        /* Card backgrounds by type */
        .card-position {
            background: linear-gradient(135deg, #5a2d6b 0%, #3d1f4a 100%);
            border: 2px solid #8b4a9e !important;
        }

        .card-intensity {
            background: linear-gradient(135deg, #d4506b 0%, #a83d55 100%);
            border: 2px solid #e8768f !important;
        }

        .card-time {
            background: linear-gradient(135deg, #6b3d5a 0%, #4a2d3d 100%);
            border: 2px solid #9e6b8b !important;
        }

        .card-special {
            background: linear-gradient(135deg, #d4a56b 0%, #a8835d 100%);
            border: 2px solid #e8c18f !important;
        }

        .card-pleasure {
            background: linear-gradient(135deg, #e8768f 0%, #d4506b 100%);
            border: 2px solid #ff9eb5 !important;
        }

        .card-body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0.5rem;
            position: relative;
        }

        .card-indicator {
            position: absolute;
            top: 6px;
            right: 6px;
            font-size: 1.2rem;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .card-emoji {
            font-size: 2.5rem;
            margin-bottom: 0.3rem;
        }

        .card-type {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: white;
            font-weight: 600;
        }

        .card-name {
            font-size: 0.8rem;
            font-weight: 700;
            margin: 0.3rem 0;
            line-height: 1.1;
            color: white;
        }

        .card-description {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.9);
            line-height: 1.2;
        }

        .btn-primary {
            background: var(--secondary-pink);
            border: 2px solid white;
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-rose);
            border: 2px solid white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 80, 107, 0.4);
        }

        .btn-success {
            background: #8b4a9e;
            border: 2px solid white;
            color: white;
        }

        .btn-success:hover {
            background: #9e6b8b;
            border: 2px solid white;
        }

        .btn-danger {
            background: #a83d55;
            border: 2px solid white;
            color: white;
        }

        .btn-danger:hover {
            background: #c44a66;
            border: 2px solid white;
        }

        .btn-info {
            background: #d4a56b;
            border: 2px solid white;
            color: white;
        }

        .btn-info:hover {
            background: #e8b87f;
            border: 2px solid white;
        }

        .btn-warning {
            background: #d4a56b;
            border: 2px solid white;
            color: white;
        }

        .btn-warning:hover {
            background: #e8b87f;
            border: 2px solid white;
        }

        .log-container {
            max-height: 200px;
            overflow-y: auto;
        }

        .border-start {
            border-color: var(--accent-rose) !important;
        }

        .bg-light {
            background: rgba(255, 245, 247, 0.1) !important;
        }

        .text-muted {
            color: rgba(255, 245, 247, 0.6) !important;
        }

        h1, h5 {
            color: var(--accent-rose);
            text-shadow: 0 2px 8px rgba(212, 80, 107, 0.3);
        }

        .badge {
            padding: 0.5rem 0.75rem;
        }

        .modal-content {
            background: var(--primary-purple);
            color: var(--soft-cream);
            border: 2px solid var(--secondary-pink);
        }

        .modal-header {
            border-color: var(--secondary-pink);
        }

        .modal-footer {
            border-color: var(--secondary-pink);
        }

        /* Toast notification */
        .toast-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--secondary-pink), var(--primary-purple));
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(212, 80, 107, 0.4);
            z-index: 9999;
            animation: slideIn 0.3s ease-out;
            font-weight: 500;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <!-- Cards loaded dynamically based on theme selection -->
</head>
<body>
    <div id="root"></div>

    <script>
        // Helper functions for card operations
        window.getAllMainDeckCards = function() {
            const { mainDeck } = window.GAME_CARDS;
            return [...mainDeck.position, ...mainDeck.intensity, ...mainDeck.time, ...mainDeck.special];
        };

        window.shuffleDeck = function(deck) {
            const shuffled = [...deck];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        };

        const { useState, useEffect, useRef } = React;

        function App() {
            const [logs, setLogs] = useState([]);
            const [status, setStatus] = useState('initializing');
            const [isPlayer1, setIsPlayer1] = useState(false);
            const [gameLink, setGameLink] = useState('');
            const [connected, setConnected] = useState(false);
            const [theme, setTheme] = useState(null); // 'fantasy' or 'original'
            const [cardsLoaded, setCardsLoaded] = useState(false);
            const [showThemeSelector, setShowThemeSelector] = useState(false);

            // Game state
            const [gameState, setGameState] = useState(null);
            const [selectedCards, setSelectedCards] = useState([]);
            const [winner, setWinner] = useState(null);
            const [sessionId, setSessionId] = useState(null);
            const [showAskDialog, setShowAskDialog] = useState(false);
            const [askingCardType, setAskingCardType] = useState(null);
            const [logsCollapsed, setLogsCollapsed] = useState(true);
            const [toast, setToast] = useState(null);
            const [showPleasureDialog, setShowPleasureDialog] = useState(false);
            const [pleasureDialogType, setPleasureDialogType] = useState(null); // 'random' or 'choose'
            const [showEquipmentDialog, setShowEquipmentDialog] = useState(false);
            const [drawnEquipment, setDrawnEquipment] = useState(null);
            const [drawnPleasure, setDrawnPleasure] = useState(null);
            const [countdownActive, setCountdownActive] = useState(false);
            const [countdownCard, setCountdownCard] = useState(null);
            const [countdownType, setCountdownType] = useState(null); // 'punishment' or 'pleasure'
            const [timeRemaining, setTimeRemaining] = useState(0);

            const peerRef = useRef(null);
            const connRef = useRef(null);
            const qrRef = useRef(null);
            const previousTurnRef = useRef(null);
            const countdownIntervalRef = useRef(null);

            const addLog = (message) => {
                const time = new Date().toLocaleTimeString();
                setLogs(prev => [...prev, { time, message }]);
            };

            // Start countdown for punishment or pleasure
            const startCountdown = (card, type) => {
                let duration;
                if (type === 'punishment' && card.time) {
                    duration = card.time.duration;
                } else if (type === 'pleasure' && card.duration) {
                    // Parse duration string (e.g., "5 min" -> 300 seconds)
                    const match = card.duration.match(/(\d+)\s*min/);
                    duration = match ? parseInt(match[1]) * 60 : 0;
                } else {
                    duration = 0;
                }

                if (duration === 0) {
                    addLog(`‚ö†Ô∏è No duration for ${type}`);
                    return;
                }

                setCountdownCard(card);
                setCountdownType(type);
                setTimeRemaining(duration);
                setCountdownActive(true);
                addLog(`‚è±Ô∏è Started ${type} countdown: ${Math.floor(duration / 60)}m ${duration % 60}s`);
            };

            // Stop countdown
            const stopCountdown = () => {
                if (countdownIntervalRef.current) {
                    clearInterval(countdownIntervalRef.current);
                    countdownIntervalRef.current = null;
                }
                setCountdownActive(false);
                setCountdownCard(null);
                setCountdownType(null);
                setTimeRemaining(0);
                addLog('‚èπÔ∏è Countdown stopped');
            };

            // Countdown timer effect
            useEffect(() => {
                if (countdownActive && timeRemaining > 0) {
                    countdownIntervalRef.current = setInterval(() => {
                        setTimeRemaining(prev => {
                            if (prev <= 1) {
                                // Timer finished
                                clearInterval(countdownIntervalRef.current);
                                countdownIntervalRef.current = null;
                                setTimeout(() => {
                                    setCountdownActive(false);
                                    setCountdownCard(null);
                                    setCountdownType(null);
                                    playNotificationSound();
                                    addLog('‚úÖ Countdown completed!');
                                }, 500);
                                return 0;
                            }
                            return prev - 1;
                        });
                    }, 1000);

                    return () => {
                        if (countdownIntervalRef.current) {
                            clearInterval(countdownIntervalRef.current);
                        }
                    };
                }
            }, [countdownActive, timeRemaining]);

            // Load cards dynamically based on theme
            const loadCards = (selectedTheme) => {
                return new Promise((resolve, reject) => {
                    // Remove existing card scripts
                    const existingScripts = document.querySelectorAll('script[src*="cards"]');
                    existingScripts.forEach(s => s.remove());

                    // Clear window.GAME_CARDS
                    delete window.GAME_CARDS;

                    const script = document.createElement('script');
                    const cardsFile = selectedTheme === 'fantasy' ? 'cards_fantasy.js' : 'cards.js';
                    script.src = cardsFile;
                    script.setAttribute('data-theme', selectedTheme);
                    script.onload = () => {
                        setCardsLoaded(true);
                        setTheme(selectedTheme);
                        addLog(`‚ú® Loaded ${selectedTheme} theme`);
                        resolve();
                    };
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            };

            const playNotificationSound = () => {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Create two short beeps
                    const beep = (time, frequency) => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        oscillator.frequency.value = frequency;
                        oscillator.type = 'sine';

                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime + time);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + time + 0.1);

                        oscillator.start(audioContext.currentTime + time);
                        oscillator.stop(audioContext.currentTime + time + 0.1);
                    };

                    // Two quick beeps
                    beep(0, 800);
                    beep(0.15, 1000);
                } catch (err) {
                    console.log('Could not play notification sound:', err);
                }
            };

            // Get or create unique device ID
            const getDeviceId = () => {
                let deviceId = localStorage.getItem('deviceId');
                if (!deviceId) {
                    deviceId = 'device_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                    localStorage.setItem('deviceId', deviceId);
                    console.log('[SESSION] Created new device ID:', deviceId);
                } else {
                    console.log('[SESSION] Existing device ID:', deviceId);
                }
                return deviceId;
            };

            // Save session to localStorage with device ID
            const saveSession = (peerId, isP1, gState) => {
                const deviceId = getDeviceId();
                const session = {
                    deviceId,
                    peerId,
                    isPlayer1: isP1,
                    gameState: gState,
                    timestamp: Date.now()
                };
                localStorage.setItem('gameSession', JSON.stringify(session));
                setSessionId(peerId);
                console.log('[SESSION] Saved:', {
                    deviceId,
                    peerId,
                    isPlayer1: isP1,
                    hasGameState: !!gState,
                    queueLength: gState?.queue?.length || 0,
                    timestamp: new Date(session.timestamp).toLocaleTimeString()
                });
                addLog(`üíæ Session saved (P${isP1 ? '1' : '2'}, Queue: ${gState?.queue?.length || 0})`);
            };

            // Load session from localStorage
            const loadSession = () => {
                console.log('[SESSION] Loading session from localStorage...');
                const saved = localStorage.getItem('gameSession');
                if (!saved) {
                    console.log('[SESSION] No saved session found');
                    addLog('üìÇ No previous session found');
                    return null;
                }

                const session = JSON.parse(saved);
                const currentDeviceId = getDeviceId();
                console.log('[SESSION] Found session:', {
                    savedDeviceId: session.deviceId,
                    currentDeviceId,
                    match: session.deviceId === currentDeviceId,
                    peerId: session.peerId,
                    isPlayer1: session.isPlayer1,
                    hasGameState: !!session.gameState,
                    queueLength: session.gameState?.queue?.length || 0,
                    savedAt: new Date(session.timestamp).toLocaleString()
                });

                // Check if this is the same device
                if (session.deviceId !== currentDeviceId) {
                    console.warn('[SESSION] Device mismatch - clearing session');
                    addLog('‚ö†Ô∏è Different device detected, clearing session');
                    localStorage.removeItem('gameSession');
                    return null;
                }

                // Session expires after 24 hours
                const age = Date.now() - session.timestamp;
                const ageHours = (age / (1000 * 60 * 60)).toFixed(1);
                console.log('[SESSION] Session age:', ageHours, 'hours');

                if (age < 24 * 60 * 60 * 1000) {
                    addLog(`‚úÖ Loaded session (${ageHours}h old, Queue: ${session.gameState?.queue?.length || 0})`);
                    return session;
                }

                console.warn('[SESSION] Session expired - clearing');
                addLog('‚è∞ Session expired (>24h old)');
                localStorage.removeItem('gameSession');
                return null;
            };

            // Clear session
            const clearSession = () => {
                console.log('[SESSION] Clearing session and starting new game');
                addLog('üîÑ Starting new game...');
                localStorage.removeItem('gameSession');
                setSessionId(null);
                setTimeout(() => {
                    window.location.href = window.location.pathname;
                }, 500);
            };

            // Initialize game state
            const initializeGame = (asPlayer1) => {
                const { GAME_CARDS, getAllMainDeckCards, shuffleDeck } = window;
                const mainDeck = shuffleDeck(getAllMainDeckCards());
                const equipmentDeck = shuffleDeck([...GAME_CARDS.equipmentDeck]);
                const pleasureDeck = shuffleDeck([...GAME_CARDS.pleasureDeck]);

                const state = {
                    mainDeck,
                    equipmentDeck,
                    pleasureDeck,
                    player1: {
                        hand: mainDeck.splice(0, 5),
                        points: 0,
                    },
                    player2: {
                        hand: mainDeck.splice(0, 5),
                        points: 0,
                        pleasureCards: [],
                    },
                    queue: [],
                    currentTurn: 1, // 1 or 2
                    discardPile: [],
                };

                return state;
            };

            useEffect(() => {
                console.log('[INIT] Starting initialization...');
                const urlParams = new URLSearchParams(window.location.search);
                let peerId = urlParams.get('peer');
                let themeParam = urlParams.get('theme') || 'fantasy'; // Default to fantasy
                console.log('[INIT] URL peer ID:', peerId || '(none)');
                console.log('[INIT] Theme:', themeParam);

                // For Player 2, load cards automatically from URL
                if (peerId && !cardsLoaded) {
                    loadCards(themeParam).catch(err => {
                        console.error('[INIT] Failed to load cards:', err);
                        addLog('‚ùå Failed to load game cards');
                    });
                    return; // Wait for cards to load
                }

                // For Player 1, auto-load theme (check preference or default to fantasy)
                if (!peerId && !theme) {
                    setIsPlayer1(true);
                    const preferredTheme = sessionStorage.getItem('preferredTheme') || 'fantasy';
                    sessionStorage.removeItem('preferredTheme'); // Clear after reading
                    loadCards(preferredTheme).then(() => {
                        addLog(`‚ú® ${preferredTheme} theme loaded`);
                    }).catch(err => {
                        console.error('[INIT] Failed to load theme:', err);
                        addLog('‚ùå Failed to load game cards');
                    });
                    return; // Waiting for cards to load
                }

                // Try to load saved session
                const savedSession = loadSession();

                // If no peer ID in URL but we have a saved session for Player 2, restore it
                if (!peerId && savedSession && !savedSession.isPlayer1 && savedSession.peerId) {
                    console.log('[INIT] Player 2 refresh detected - restoring URL');
                    peerId = savedSession.peerId;
                    // Redirect to the proper URL with peer ID
                    window.history.replaceState({}, '', `${window.location.pathname}?peer=${peerId}`);
                    addLog('üîÑ Restoring Player 2 session...');
                }

                if (!peerId) {
                    // Player 1: Create peer after theme is selected
                    console.log('[INIT] No peer ID in URL - Player 1 mode');

                    // Try to reuse the same peer ID from saved session
                    let savedPeerId = null;
                    if (savedSession && savedSession.isPlayer1 && savedSession.peerId) {
                        savedPeerId = savedSession.peerId;
                        console.log('[INIT] Attempting to reuse Player 1 peer ID:', savedPeerId);
                        addLog(`üîÑ Restoring Player 1 session (ID: ${savedPeerId.substring(0, 8)}...)`);
                        if (savedSession.gameState) {
                            console.log('[INIT] Restoring game state for Player 1');
                            setGameState(savedSession.gameState);
                            addLog(`‚úÖ Game state restored (Queue: ${savedSession.gameState.queue.length})`);
                        }
                    } else {
                        console.log('[INIT] No saved session - creating new Player 1');
                        addLog('üÜï Initializing as Player 1...');
                    }

                    const peer = new Peer(savedPeerId, {
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', (id) => {
                        console.log('[PEER] Player 1 peer opened with ID:', id);
                        addLog(`‚úÖ Peer created with ID: ${id.substring(0, 8)}...`);
                        const link = `${window.location.origin}${window.location.pathname}?peer=${id}&theme=${theme}`;
                        setGameLink(link);
                        setStatus('waiting');
                        setSessionId(id);

                        if (savedPeerId && id === savedPeerId) {
                            console.log('[PEER] Successfully reused peer ID');
                            addLog('‚úÖ Session restored with same peer ID');
                        } else if (savedPeerId) {
                            console.warn('[PEER] Peer ID changed! Old:', savedPeerId, 'New:', id);
                            addLog('‚ö†Ô∏è New peer ID assigned (old one unavailable)');
                        }

                        addLog('‚è≥ Waiting for Player 2 to connect...');
                        addLog('üì§ Share the link below to invite them!');

                        // Generate QR code
                        setTimeout(() => {
                            if (qrRef.current && window.QRCode) {
                                qrRef.current.innerHTML = '';
                                new QRCode(qrRef.current, {
                                    text: link,
                                    width: 200,
                                    height: 200,
                                    colorDark: '#000000',
                                    colorLight: '#ffffff',
                                    correctLevel: QRCode.CorrectLevel.M
                                });
                            }
                        }, 100);
                    });

                    peer.on('connection', (conn) => {
                        console.log('[PEER] Player 2 is connecting...');
                        addLog('üîó Player 2 is connecting...');
                        connRef.current = conn;
                        setupConnection(conn, true);
                    });

                    peer.on('error', (err) => {
                        console.error('[PEER] Error:', err.type, err.message);
                        addLog(`‚ùå Error: ${err.message}`);
                        // If peer ID is already taken, try with a new one
                        if (err.type === 'unavailable-id' || err.type === 'invalid-id') {
                            console.warn('[PEER] Peer ID unavailable, clearing session and reloading');
                            addLog('‚ö†Ô∏è Peer ID unavailable, creating new session...');
                            localStorage.removeItem('gameSession');
                            setTimeout(() => window.location.reload(), 1000);
                        }
                    });

                } else {
                    // Player 2: Connect to Player 1
                    console.log('[INIT] Peer ID in URL - initializing as Player 2');
                    setIsPlayer1(false);
                    setStatus('connecting');

                    // Restore game state if exists
                    if (savedSession && !savedSession.isPlayer1 && savedSession.gameState) {
                        console.log('[INIT] Restoring game state for Player 2');
                        addLog(`üîÑ Restoring Player 2 session (Queue: ${savedSession.gameState.queue.length})`);
                        setGameState(savedSession.gameState);
                    } else {
                        console.log('[INIT] No saved session for Player 2 - connecting fresh');
                        addLog('üÜï Initializing as Player 2...');
                    }

                    // Save peer ID for reconnection
                    console.log('[INIT] Saving Player 2 peer ID:', peerId);
                    saveSession(peerId, false, savedSession?.gameState || null);
                    setSessionId(peerId);

                    const peer = new Peer({
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:stun1.l.google.com:19302' }
                            ]
                        }
                    });

                    peerRef.current = peer;

                    peer.on('open', () => {
                        console.log('[PEER] Player 2 peer initialized');
                        addLog('‚úÖ Peer initialized');
                        addLog(`üîó Connecting to Player 1 (ID: ${peerId.substring(0, 8)}...)...`);

                        const conn = peer.connect(peerId, {
                            reliable: true
                        });

                        console.log('[PEER] Player 2 attempting connection to Player 1');
                        connRef.current = conn;
                        setupConnection(conn, false);
                    });

                    peer.on('error', (err) => {
                        console.error('[PEER] Player 2 error:', err.type, err.message);
                        addLog(`‚ùå Error: ${err.message}`);
                    });
                }

                return () => {
                    if (connRef.current) {
                        connRef.current.close();
                    }
                    if (peerRef.current) {
                        peerRef.current.destroy();
                    }
                };
            }, [cardsLoaded, theme]);

            // Auto-save game state changes for BOTH players
            useEffect(() => {
                if (gameState && sessionId) {
                    console.log('[AUTO-SAVE] Saving game state change');
                    saveSession(sessionId, isPlayer1, gameState);
                }
            }, [gameState]);

            // Play notification sound when it becomes your turn
            useEffect(() => {
                if (gameState && connected) {
                    const currentTurn = isMyTurn();
                    const previousTurn = previousTurnRef.current;

                    // If it just became your turn (was false, now true)
                    if (currentTurn && previousTurn === false) {
                        playNotificationSound();
                    }

                    // Update the ref
                    previousTurnRef.current = currentTurn;
                }
            }, [gameState?.currentTurn, connected]);

            const setupConnection = (conn, asPlayer1) => {
                conn.on('open', () => {
                    console.log('[CONNECTION] Connection opened! Player:', asPlayer1 ? 1 : 2);
                    addLog('‚úÖ Connection opened!');
                    addLog('‚úÖ ICE route finding complete');
                    setStatus('connected');
                    setConnected(true);

                    if (asPlayer1) {
                        // Player 1 initializes the game or uses saved state
                        // Use a small delay to ensure React state has been updated from restoration
                        setTimeout(() => {
                            console.log('[CONNECTION] Player 1 checking for existing game state');
                            setGameState(prevState => {
                                let initialState = prevState;
                                if (!initialState) {
                                    console.log('[CONNECTION] No game state - initializing new game');
                                    initialState = initializeGame(true);
                                    addLog('üéÆ New game initialized');
                                } else {
                                    console.log('[CONNECTION] Using existing game state (Queue:', initialState.queue.length, ')');
                                    addLog(`üéÆ Resuming game (Queue: ${initialState.queue.length})`);
                                }
                                console.log('[CONNECTION] Sending game state to Player 2');
                                sendGameState(initialState);
                                // Save session
                                saveSession(peerRef.current?.id, true, initialState);
                                addLog('‚úÖ Player 1 starts.');
                                return initialState;
                            });
                        }, 100);
                    } else {
                        console.log('[CONNECTION] Player 2 waiting for game state from Player 1');
                        addLog('‚è≥ Waiting for game initialization...');
                    }
                });

                conn.on('data', (data) => {
                    handleMessage(data);
                });

                conn.on('close', () => {
                    console.log('[CONNECTION] Connection closed');
                    addLog('‚ùå Connection closed');
                    setConnected(false);
                    setStatus('disconnected');
                });

                conn.on('error', (err) => {
                    console.error('[CONNECTION] Connection error:', err.message);
                    addLog(`‚ùå Connection error: ${err.message}`);
                });
            };

            const sendGameState = (state) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'gameState',
                        state: state
                    });
                }
            };

            const sendAction = (action) => {
                if (connRef.current && connRef.current.open) {
                    connRef.current.send({
                        type: 'action',
                        action: action
                    });
                }
            };

            const handleMessage = (data) => {
                console.log('[MESSAGE] Received:', data.type);
                if (data.type === 'gameState') {
                    console.log('[MESSAGE] Updating game state (Queue:', data.state.queue.length, ')');
                    setGameState(data.state);
                    // Save updated state for BOTH players
                    const peerId = isPlayer1 ? peerRef.current?.id : sessionId;
                    if (peerId) {
                        console.log('[MESSAGE] Saving received game state for', isPlayer1 ? 'P1' : 'P2');
                        saveSession(peerId, isPlayer1, data.state);
                    }
                    addLog('üì• Game state updated');
                } else if (data.type === 'action') {
                    console.log('[MESSAGE] Processing action:', data.action.type);
                    processAction(data.action);
                } else if (data.type === 'winner') {
                    console.log('[MESSAGE] Winner declared:', data.winner);
                    setWinner(data.winner === 'opponent' ? 'opponent' : 'me');
                    addLog(data.winner === 'opponent' ? 'üéâ Opponent won!' : 'üòî You won!');
                }
            };

            const processAction = (action) => {
                // Process opponent's action and update game state
                setGameState(prevState => {
                    const newState = { ...prevState };

                    switch (action.type) {
                        case 'playSet':
                            // Add set to queue
                            newState.queue.push(action.set);
                            // Update player stats
                            if (action.player === 1) {
                                newState.player1.points += 1;
                            }
                            // Switch turn
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent played a set`);
                            break;

                        case 'discard':
                            newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;
                            addLog(`Opponent discarded a card`);
                            break;

                        case 'drawEquipment':
                            addLog(`Opponent drew equipment`);
                            break;

                        case 'drawPleasure':
                            addLog(`Opponent drew a pleasure card`);
                            break;

                        case 'drawCard':
                            addLog(`Opponent drew a card`);
                            break;

                        case 'stealCard':
                            addLog(`Opponent used Steal Card`);
                            break;

                        case 'askForCard':
                            addLog(`Opponent used Ask For Card (${action.requestedType})`);
                            break;
                    }

                    return newState;
                });
            };

            const handleCardClick = (card) => {
                if (!isMyTurn()) return;

                setSelectedCards(prev => {
                    const isSelected = prev.find(c => c.id === card.id);
                    if (isSelected) {
                        return prev.filter(c => c.id !== card.id);
                    } else {
                        return [...prev, card];
                    }
                });
            };

            const isMyTurn = () => {
                if (!gameState) return false;
                return (isPlayer1 && gameState.currentTurn === 1) ||
                       (!isPlayer1 && gameState.currentTurn === 2);
            };

            const canPlaySet = () => {
                if (selectedCards.length !== 3) return false;
                const hasPosition = selectedCards.some(c => c.type === 'position');
                const hasIntensity = selectedCards.some(c => c.type === 'intensity');
                const hasTime = selectedCards.some(c => c.type === 'time');
                return hasPosition && hasIntensity && hasTime;
            };

            const handleDrawCard = () => {
                if (!isMyTurn() || !gameState) return;

                const playerKey = isPlayer1 ? 'player1' : 'player2';
                const currentHand = gameState[playerKey].hand;

                // Can only draw if hand has less than 5 cards
                if (currentHand.length >= 5) {
                    addLog('‚ö†Ô∏è Cannot draw - hand is full (max 5 cards)');
                    return;
                }

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // If main deck is empty, reshuffle discard pile
                    if (newState.mainDeck.length === 0 && newState.discardPile.length > 0) {
                        console.log('[DRAW] Main deck empty, reshuffling discard pile');
                        newState.mainDeck = window.shuffleDeck([...newState.discardPile]);
                        newState.discardPile = [];
                        addLog('‚ôªÔ∏è Reshuffled discard pile into deck');
                    }

                    if (newState.mainDeck.length > 0) {
                        const drawnCard = newState.mainDeck.shift();
                        newState[playerKey].hand.push(drawnCard);
                        addLog(`Drew: ${drawnCard.name}`);
                    } else {
                        addLog('‚ö†Ô∏è No cards left to draw');
                    }

                    // Switch turn after drawing
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    // Send state after update
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                const action = {
                    type: 'drawCard'
                };
                sendAction(action);
            };

            const handlePlaySet = () => {
                if (!canPlaySet() || !gameState) return;

                const position = selectedCards.find(c => c.type === 'position');
                const intensity = selectedCards.find(c => c.type === 'intensity');
                const time = selectedCards.find(c => c.type === 'time');

                const set = {
                    position,
                    intensity,
                    time,
                    equipment: []
                };

                let updatedState;

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove cards from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => !selectedCards.find(sc => sc.id === c.id)
                    );

                    // Update player stats
                    if (isPlayer1) {
                        // Player 1: Add to queue and get points
                        newState.queue.push(set);
                        newState.player1.points += 1;
                    } else {
                        // Player 2: Add cards randomly back to main deck and get points
                        const cardsToReturn = [position, intensity, time];
                        cardsToReturn.forEach(card => {
                            const randomIndex = Math.floor(Math.random() * (newState.mainDeck.length + 1));
                            newState.mainDeck.splice(randomIndex, 0, card);
                        });
                        newState.player2.points += 1;
                        addLog(`+1 point (now ${newState.player2.points})`);
                    }

                    // Check win conditions
                    let hasWon = false;
                    if (newState.queue.length >= 5 && isPlayer1) {
                        hasWon = true;
                    } else if (newState.player2.pleasureCards.length >= 5 && !isPlayer1) {
                        hasWon = true;
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    addLog(`Played set: ${position.name} + ${intensity.name} + ${time.name}`);

                    // Notify about win
                    if (hasWon) {
                        setWinner('me');
                        setTimeout(() => {
                            if (connRef.current && connRef.current.open) {
                                connRef.current.send({
                                    type: 'winner',
                                    winner: 'opponent'
                                });
                            }
                        }, 100);
                    }

                    // Store updated state for sending
                    updatedState = newState;

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'playSet',
                    player: isPlayer1 ? 1 : 2,
                    set
                };
                sendAction(action);

                // Send the updated state
                setTimeout(() => {
                    if (connRef.current && connRef.current.open && updatedState) {
                        sendGameState(updatedState);
                    }
                }, 50);
            };

            const handleDiscard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || !gameState) return;

                const discardedCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';

                    // Remove card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== discardedCard.id
                    );

                    // Add to discard pile
                    newState.discardPile.push(discardedCard);

                    // Draw a replacement card from main deck
                    if (newState.mainDeck.length === 0 && newState.discardPile.length > 0) {
                        console.log('[DISCARD] Main deck empty, reshuffling discard pile');
                        newState.mainDeck = window.shuffleDeck([...newState.discardPile]);
                        newState.discardPile = [];
                        addLog('‚ôªÔ∏è Reshuffled discard pile into deck');
                    }

                    if (newState.mainDeck.length > 0) {
                        const drawnCard = newState.mainDeck.shift();
                        newState[playerKey].hand.push(drawnCard);
                        addLog(`Discarded: ${discardedCard.name}, drew: ${drawnCard.name}`);
                    } else {
                        addLog(`Discarded: ${discardedCard.name}`);
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    // Send updated state
                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'discard'
                };
                sendAction(action);
            };

            const handleDrawEquipment = (type) => {
                if (!isPlayer1 || !gameState) return;

                const cost = type === 'random' ? 1 : 3;

                if (gameState.player1.points < cost) {
                    addLog(`Need ${cost} points for equipment`);
                    return;
                }

                if (type === 'random') {
                    // Random equipment for 1 point
                    setGameState(prev => {
                        const newState = { ...prev };

                        if (newState.equipmentDeck.length > 0 && newState.queue.length > 0) {
                            const equipment = newState.equipmentDeck.shift();
                            newState.queue[newState.queue.length - 1].equipment.push(equipment);
                            newState.player1.points -= 1;
                            addLog(`Added equipment: ${equipment.name}`);

                            // Show modal with drawn equipment
                            setDrawnEquipment(equipment);

                            // Send updated state
                            setTimeout(() => {
                                sendGameState(newState);
                            }, 50);
                        }

                        return newState;
                    });

                    const action = {
                        type: 'drawEquipment'
                    };
                    sendAction(action);
                } else {
                    // Open dialog to choose equipment for 3 points
                    setShowEquipmentDialog(true);
                }
            };

            // Execute chosen equipment purchase
            const executeChooseEquipment = (equipment) => {
                setShowEquipmentDialog(false);

                setGameState(prev => {
                    const newState = { ...prev };

                    if (newState.queue.length > 0) {
                        // Remove the chosen card from equipment deck
                        newState.equipmentDeck = newState.equipmentDeck.filter(e => e.id !== equipment.id);
                        newState.queue[newState.queue.length - 1].equipment.push(equipment);
                        newState.player1.points -= 3;
                        addLog(`Chose equipment: ${equipment.name}`);

                        setTimeout(() => {
                            sendGameState(newState);
                        }, 50);
                    }

                    return newState;
                });
            };

            // Handle playing a special card (Steal Card)
            const handleStealCard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || selectedCards[0].type !== 'special' || selectedCards[0].action !== 'steal') return;

                const specialCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';
                    const opponentKey = isPlayer1 ? 'player2' : 'player1';

                    // Remove special card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== specialCard.id
                    );

                    // Discard the special card
                    newState.discardPile.push(specialCard);

                    // Steal random card from opponent if they have any
                    if (newState[opponentKey].hand.length > 0) {
                        const randomIndex = Math.floor(Math.random() * newState[opponentKey].hand.length);
                        const stolenCard = newState[opponentKey].hand.splice(randomIndex, 1)[0];
                        newState[playerKey].hand.push(stolenCard);
                        addLog(`Stole ${stolenCard.name} from opponent!`);
                    } else {
                        addLog('Opponent has no cards to steal');
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);

                const action = {
                    type: 'stealCard',
                    cardId: specialCard.id
                };
                sendAction(action);
            };

            // Handle "Ask For Card" - show dialog
            const handleAskForCard = () => {
                if (!isMyTurn() || selectedCards.length !== 1 || selectedCards[0].type !== 'special' || selectedCards[0].action !== 'ask') return;
                setShowAskDialog(true);
            };

            // Execute ask for card with selected type
            const executeAskForCard = (cardType) => {
                if (!cardType) return;

                const specialCard = selectedCards[0];

                setGameState(prev => {
                    const newState = { ...prev };
                    const playerKey = isPlayer1 ? 'player1' : 'player2';
                    const opponentKey = isPlayer1 ? 'player2' : 'player1';

                    // Remove special card from hand
                    newState[playerKey].hand = newState[playerKey].hand.filter(
                        c => c.id !== specialCard.id
                    );

                    // Discard the special card
                    newState.discardPile.push(specialCard);

                    // Find card of requested type from opponent
                    const requestedCard = newState[opponentKey].hand.find(c => c.type === cardType);
                    if (requestedCard) {
                        newState[opponentKey].hand = newState[opponentKey].hand.filter(c => c.id !== requestedCard.id);
                        newState[playerKey].hand.push(requestedCard);
                        addLog(`Received ${requestedCard.name} from opponent!`);
                    } else {
                        addLog(`Opponent doesn't have a ${cardType} card`);
                    }

                    // Switch turn
                    newState.currentTurn = newState.currentTurn === 1 ? 2 : 1;

                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });

                setSelectedCards([]);
                setShowAskDialog(false);

                const action = {
                    type: 'askForCard',
                    cardId: specialCard.id,
                    requestedType: cardType
                };
                sendAction(action);
            };

            const showToast = (message) => {
                setToast(message);
                setTimeout(() => setToast(null), 3000);
            };

            const copyLink = async () => {
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(gameLink);
                        showToast('‚úÖ Link copied to clipboard!');
                        addLog('Link copied to clipboard!');
                    } else {
                        const textarea = document.createElement('textarea');
                        textarea.value = gameLink;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        showToast('‚úÖ Link copied to clipboard!');
                        addLog('Link copied to clipboard!');
                    }
                } catch (err) {
                    showToast('‚ùå Failed to copy link');
                    addLog('Failed to copy link');
                }
            };

            const shareLink = async () => {
                if (navigator.share) {
                    try {
                        await navigator.share({
                            title: 'The GAME',
                            text: 'Join me in a card game!',
                            url: gameLink
                        });
                        addLog('Link shared!');
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            addLog('Share failed, use copy instead');
                        }
                    }
                } else {
                    copyLink();
                }
            };

            // Handle buying pleasure card with points
            const handleBuyPleasure = (type) => {
                if (!gameState || isPlayer1) return; // Only Player 2 can buy pleasure cards

                const myStats = gameState.player2;
                const cost = type === 'random' ? 1 : 3;

                if (myStats.points < cost) {
                    addLog(`Need ${cost} points to buy pleasure card`);
                    return;
                }

                if (type === 'random') {
                    // Buy random pleasure card for 1 point
                    setGameState(prev => {
                        const newState = { ...prev };

                        if (newState.pleasureDeck.length > 0) {
                            const pleasureCard = newState.pleasureDeck.shift();
                            newState.player2.pleasureCards.push(pleasureCard);
                            newState.player2.points -= 1;
                            addLog(`Drew random pleasure: ${pleasureCard.name}`);

                            // Show modal with drawn pleasure
                            setDrawnPleasure(pleasureCard);

                            // Check win condition
                            if (newState.player2.pleasureCards.length >= 5) {
                                setWinner('me');
                                setTimeout(() => {
                                    if (connRef.current && connRef.current.open) {
                                        connRef.current.send({
                                            type: 'winner',
                                            winner: 'opponent'
                                        });
                                    }
                                }, 100);
                            }
                        } else {
                            addLog('No pleasure cards left!');
                        }

                        setTimeout(() => {
                            sendGameState(newState);
                        }, 50);

                        return newState;
                    });
                } else {
                    // Open dialog to choose specific pleasure card for 3 points
                    setPleasureDialogType('choose');
                    setShowPleasureDialog(true);
                }
            };

            // Execute chosen pleasure card purchase
            const executeChoosePleasure = (pleasureCard) => {
                setShowPleasureDialog(false);
                setPleasureDialogType(null);

                setGameState(prev => {
                    const newState = { ...prev };

                    // Remove the chosen card from pleasure deck
                    newState.pleasureDeck = newState.pleasureDeck.filter(c => c.id !== pleasureCard.id);
                    newState.player2.pleasureCards.push(pleasureCard);
                    newState.player2.points -= 3;
                    addLog(`Chose pleasure: ${pleasureCard.name}`);

                    // Check win condition
                    if (newState.player2.pleasureCards.length >= 5) {
                        setWinner('me');
                        setTimeout(() => {
                            if (connRef.current && connRef.current.open) {
                                connRef.current.send({
                                    type: 'winner',
                                    winner: 'opponent'
                                });
                            }
                        }, 100);
                    }

                    setTimeout(() => {
                        sendGameState(newState);
                    }, 50);

                    return newState;
                });
            };

            const myHand = gameState && (isPlayer1 ? gameState.player1.hand : gameState.player2.hand);
            const myStats = gameState && (isPlayer1 ? gameState.player1 : gameState.player2);

            return React.createElement('div', { className: 'container my-4' },
                toast && React.createElement('div', { className: 'toast-notification' }, toast),

                React.createElement('div', { className: 'd-flex justify-content-between align-items-center mb-4' },
                    React.createElement('h1', { className: 'mb-0' },
                        connected && gameState
                            ? React.createElement('span', null,
                                'üé¥ The GAME - ',
                                React.createElement('span', { style: { color: 'white' } }, isPlayer1 ? 'P1' : 'P2')
                            )
                            : 'üé¥ The GAME'
                    ),
                    React.createElement('button', {
                        className: 'btn btn-outline-danger btn-sm',
                        onClick: clearSession
                    }, 'üîÑ New Game')
                ),

                !connected && React.createElement('div', {
                    className: 'alert alert-danger text-center mb-3 py-2',
                    style: { borderColor: 'var(--secondary-pink)', color: 'white' }
                },
                    React.createElement('strong', null, 'üîû 18+ Adult Content ‚Ä¢ '),
                    React.createElement('span', { className: 'small' },
                        'Intimate P2P card game for couples exploring consensual discipline & pleasure'
                    )
                ),


                !connected && isPlayer1 && gameLink && React.createElement('div', null,
                    React.createElement('div', { className: 'border rounded p-4 mb-3 bg-light text-center mt-3' },
                        React.createElement('div', { className: 'd-flex justify-content-center mb-4' },
                            React.createElement('div', {
                                className: 'bg-white p-3 rounded',
                                ref: qrRef
                            })
                        ),
                        React.createElement('div', { className: 'd-flex justify-content-center' },
                            React.createElement('div', { className: 'btn-group', role: 'group' },
                            React.createElement('input', {
                                type: 'radio',
                                className: 'btn-check',
                                name: 'theme',
                                id: 'theme-fantasy',
                                checked: theme === 'fantasy',
                                onChange: async () => {
                                    if (theme !== 'fantasy') {
                                        addLog('üîÑ Switching to Fantasy theme...');
                                        // Just reload the page with fantasy theme
                                        window.location.href = window.location.pathname;
                                    }
                                }
                            }),
                            React.createElement('label', {
                                className: 'btn btn-lg btn-outline-primary',
                                htmlFor: 'theme-fantasy'
                            }, '‚ú® Fantasy'),
                            React.createElement('input', {
                                type: 'radio',
                                className: 'btn-check',
                                name: 'theme',
                                id: 'theme-original',
                                checked: theme === 'original',
                                onChange: async () => {
                                    if (theme !== 'original') {
                                        addLog('üîÑ Switching to Original theme...');
                                        // Store theme preference before reload
                                        sessionStorage.setItem('preferredTheme', 'original');
                                        window.location.href = window.location.pathname;
                                    }
                                }
                            }),
                            React.createElement('label', {
                                className: 'btn btn-lg btn-outline-danger',
                                htmlFor: 'theme-original'
                            }, 'üî• Original')
                            )
                        )
                    ),
                    React.createElement('button', {
                        className: 'btn btn-primary w-100 mb-3',
                        onClick: copyLink
                    }, `üìã Copy Link: ${gameLink.substring(0, 15)}...`)
                ),

                !connected && !isPlayer1 && React.createElement('div', { className: 'alert alert-info' },
                    React.createElement('strong', null, 'üîó Connecting to Player 1...'),
                    React.createElement('p', { className: 'mt-2 mb-0' },
                        'This may take 5-10 seconds while finding the best route...'
                    )
                ),

                connected && gameState && React.createElement('div', { className: 'vstack gap-3' },
                    winner && React.createElement('div', {
                        className: `alert text-center fs-4 fw-bold ${winner === 'me' ? 'alert-success' : 'alert-danger'}`
                    },
                        winner === 'me' ? 'üéâ You Won!' : 'üòî You Lost!'
                    ),


                    React.createElement('div', { className: 'card' },
                        React.createElement('div', { className: 'card-header bg-light d-flex justify-content-between align-items-center flex-wrap gap-2' },
                            React.createElement('h5', { className: 'mb-0', style: isMyTurn() ? { color: 'white' } : {} },
                                isMyTurn() ? 'üé¥ Your Turn' : '‚è≥ Opponent\'s Turn'
                            ),
                            React.createElement('div', { className: 'fs-5 fw-bold' },
                                isPlayer1
                                    ? React.createElement('span', null,
                                        React.createElement('span', { className: 'text-primary fs-3' }, gameState?.player1?.points || 0),
                                        ':',
                                        gameState?.player2?.points || 0,
                                        ' ',
                                        React.createElement('span', { className: 'text-muted small' }, `(${isPlayer1 ? gameState.player2.hand.length : gameState.player1.hand.length})`)
                                    )
                                    : React.createElement('span', null,
                                        gameState?.player1?.points || 0,
                                        ':',
                                        React.createElement('span', { className: 'text-primary fs-3' }, gameState?.player2?.points || 0),
                                        ' ',
                                        React.createElement('span', { className: 'text-muted small' }, `(${isPlayer1 ? gameState.player2.hand.length : gameState.player1.hand.length})`)
                                    )
                            )
                        ),
                        React.createElement('div', { className: 'card-body' },
                            React.createElement('div', { className: 'd-flex gap-3 flex-wrap' },
                                [...myHand].sort((a, b) => {
                                    // Sort by type first, then by name
                                    const typeOrder = { position: 1, intensity: 2, time: 3, special: 4 };
                                    const typeCompare = (typeOrder[a.type] || 5) - (typeOrder[b.type] || 5);
                                    if (typeCompare !== 0) return typeCompare;
                                    return a.name.localeCompare(b.name);
                                }).map(card => {
                                    // Determine indicator emoji based on card type
                                    let indicator = '';
                                    if (card.type === 'position') indicator = '1Ô∏è‚É£';
                                    else if (card.type === 'intensity') indicator = '2Ô∏è‚É£';
                                    else if (card.type === 'time') indicator = '3Ô∏è‚É£';
                                    else if (card.type === 'special') indicator = '‚ú®';

                                    return React.createElement('div', {
                                        className: `game-card card-${card.type} ${selectedCards.find(c => c.id === card.id) ? 'selected' : ''}`,
                                        key: card.id,
                                        onClick: () => handleCardClick(card)
                                    },
                                        React.createElement('div', { className: 'card-body' },
                                            card.emoji && React.createElement('div', { className: 'card-emoji' }, card.emoji),
                                            React.createElement('div', { className: 'card-type' }, card.type),
                                            React.createElement('div', { className: 'card-name' }, card.name),
                                            card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                            card.duration !== undefined && React.createElement('div', { className: 'card-description' },
                                                `${card.duration}s`
                                            ),
                                            React.createElement('div', { className: 'card-indicator' }, indicator)
                                        )
                                    );
                                })
                            )
                        )
                    ),

                    React.createElement('div', { className: 'd-flex gap-2 flex-wrap' },
                        myHand.length < 5 && isMyTurn() && selectedCards.length === 0 && React.createElement('button', {
                            className: 'btn btn-primary btn-lg',
                            onClick: handleDrawCard
                        }, 'üì• Draw Card (end turn)'),
                        canPlaySet() && React.createElement('button', {
                            className: 'btn btn-success btn-lg',
                            onClick: handlePlaySet
                        }, '‚úÖ Play Set (3 cards)'),
                        myHand.length >= 5 && isMyTurn() && selectedCards.length === 1 && selectedCards[0]?.type !== 'special' && React.createElement('button', {
                            className: 'btn btn-danger btn-lg',
                            onClick: handleDiscard
                        }, 'üóëÔ∏è Discard (end turn)'),
                        isMyTurn() && selectedCards.length === 1 && selectedCards[0]?.type === 'special' && selectedCards[0]?.action === 'steal' && React.createElement('button', {
                            className: 'btn btn-info btn-lg',
                            onClick: handleStealCard
                        }, 'üÉè Steal Card'),
                        isMyTurn() && selectedCards.length === 1 && selectedCards[0]?.type === 'special' && selectedCards[0]?.action === 'ask' && React.createElement('button', {
                            className: 'btn btn-info btn-lg',
                            onClick: handleAskForCard
                        }, '‚ùì Ask For Card'),
                        isPlayer1 && myStats?.points >= 1 && gameState?.queue?.length > 0 && React.createElement('button', {
                            className: 'btn btn-warning btn-lg',
                            onClick: () => handleDrawEquipment('random')
                        }, 'üîß Random Equipment (1pt)'),
                        isPlayer1 && myStats?.points >= 3 && gameState?.queue?.length > 0 && React.createElement('button', {
                            className: 'btn btn-warning btn-lg',
                            onClick: () => handleDrawEquipment('choose')
                        }, 'üîß Choose Equipment (3pts)'),
                        !isPlayer1 && myStats?.points >= 1 && React.createElement('button', {
                            className: 'btn btn-primary btn-lg',
                            onClick: () => handleBuyPleasure('random')
                        }, 'üíù Random Pleasure (1pt)'),
                        !isPlayer1 && myStats?.points >= 3 && React.createElement('button', {
                            className: 'btn btn-success btn-lg',
                            onClick: () => handleBuyPleasure('choose')
                        }, 'üíù Choose Pleasure (3pts)')
                    ),

                    showAskDialog && React.createElement('div', {
                        className: 'modal show d-block',
                        style: { backgroundColor: 'rgba(0,0,0,0.5)' },
                        onClick: () => setShowAskDialog(false)
                    },
                        React.createElement('div', {
                            className: 'modal-dialog modal-dialog-centered',
                            onClick: (e) => e.stopPropagation()
                        },
                            React.createElement('div', { className: 'modal-content' },
                                React.createElement('div', { className: 'modal-header' },
                                    React.createElement('h5', { className: 'modal-title' }, '‚ùì Ask For Card Type'),
                                    React.createElement('button', {
                                        type: 'button',
                                        className: 'btn-close',
                                        onClick: () => setShowAskDialog(false)
                                    })
                                ),
                                React.createElement('div', { className: 'modal-body' },
                                    React.createElement('p', null, 'Choose which type of card to request from your opponent:'),
                                    React.createElement('div', { className: 'd-grid gap-2' },
                                        React.createElement('button', {
                                            className: 'btn btn-primary',
                                            onClick: () => executeAskForCard('position')
                                        }, 'üìç Position Card'),
                                        React.createElement('button', {
                                            className: 'btn btn-danger',
                                            onClick: () => executeAskForCard('intensity')
                                        }, 'üí™ Intensity Card'),
                                        React.createElement('button', {
                                            className: 'btn btn-success',
                                            onClick: () => executeAskForCard('time')
                                        }, '‚è±Ô∏è Time Card'),
                                        React.createElement('button', {
                                            className: 'btn btn-warning',
                                            onClick: () => executeAskForCard('special')
                                        }, '‚ú® Special Card')
                                    )
                                ),
                                React.createElement('div', { className: 'modal-footer' },
                                    React.createElement('button', {
                                        className: 'btn btn-secondary',
                                        onClick: () => setShowAskDialog(false)
                                    }, 'Cancel')
                                )
                            )
                        )
                    )
                ),

                showPleasureDialog && React.createElement('div', {
                    className: 'modal show d-block',
                    style: { backgroundColor: 'rgba(0,0,0,0.5)' },
                    onClick: () => setShowPleasureDialog(false)
                },
                    React.createElement('div', {
                        className: 'modal-dialog modal-dialog-centered modal-lg',
                        onClick: (e) => e.stopPropagation()
                    },
                        React.createElement('div', { className: 'modal-content' },
                            React.createElement('div', { className: 'modal-header' },
                                React.createElement('h5', { className: 'modal-title' }, 'üíù Choose Pleasure Card'),
                                React.createElement('button', {
                                    type: 'button',
                                    className: 'btn-close',
                                    onClick: () => setShowPleasureDialog(false)
                                })
                            ),
                            React.createElement('div', { className: 'modal-body' },
                                React.createElement('p', null, 'Choose a pleasure card (costs 3 points):'),
                                React.createElement('div', { className: 'd-flex gap-3 flex-wrap justify-content-center' },
                                    (() => {
                                        // Get unique pleasure cards by name
                                        const seen = new Set();
                                        return gameState?.pleasureDeck?.filter(card => {
                                            if (seen.has(card.name)) return false;
                                            seen.add(card.name);
                                            return true;
                                        }) || [];
                                    })().map((card, idx) =>
                                        React.createElement('div', {
                                            className: 'game-card card-pleasure',
                                            key: idx,
                                            style: { cursor: 'pointer' },
                                            onClick: () => executeChoosePleasure(card)
                                        },
                                            React.createElement('div', { className: 'card-body' },
                                                card.emoji && React.createElement('div', { className: 'card-emoji' }, card.emoji),
                                                React.createElement('div', { className: 'card-type' }, 'pleasure'),
                                                React.createElement('div', { className: 'card-name' }, card.name),
                                                card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                                card.duration && React.createElement('div', { className: 'card-description' }, card.duration)
                                            )
                                        )
                                    )
                                )
                            ),
                            React.createElement('div', { className: 'modal-footer' },
                                React.createElement('button', {
                                    className: 'btn btn-secondary',
                                    onClick: () => setShowPleasureDialog(false)
                                }, 'Cancel')
                            )
                        )
                    )
                ),

                showEquipmentDialog && React.createElement('div', {
                    className: 'modal show d-block',
                    style: { backgroundColor: 'rgba(0,0,0,0.5)' },
                    onClick: () => setShowEquipmentDialog(false)
                },
                    React.createElement('div', {
                        className: 'modal-dialog modal-dialog-centered modal-lg',
                        onClick: (e) => e.stopPropagation()
                    },
                        React.createElement('div', { className: 'modal-content' },
                            React.createElement('div', { className: 'modal-header' },
                                React.createElement('h5', { className: 'modal-title' }, 'üîß Choose Equipment'),
                                React.createElement('button', {
                                    type: 'button',
                                    className: 'btn-close',
                                    onClick: () => setShowEquipmentDialog(false)
                                })
                            ),
                            React.createElement('div', { className: 'modal-body' },
                                React.createElement('p', null, 'Choose an equipment card (costs 3 points):'),
                                React.createElement('div', { className: 'd-flex gap-3 flex-wrap justify-content-center' },
                                    (() => {
                                        // Get unique equipment by name
                                        const seen = new Set();
                                        return gameState?.equipmentDeck?.filter(card => {
                                            if (seen.has(card.name)) return false;
                                            seen.add(card.name);
                                            return true;
                                        }) || [];
                                    })().map((card, idx) =>
                                        React.createElement('div', {
                                            className: 'game-card card-equipment',
                                            key: idx,
                                            style: { cursor: 'pointer' },
                                            onClick: () => executeChooseEquipment(card)
                                        },
                                            React.createElement('div', { className: 'card-body' },
                                                card.emoji && React.createElement('div', { className: 'card-emoji' }, card.emoji),
                                                React.createElement('div', { className: 'card-type' }, 'equipment'),
                                                React.createElement('div', { className: 'card-name' }, card.name),
                                                card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                                card.duration && React.createElement('div', { className: 'card-description' }, card.duration)
                                            )
                                        )
                                    )
                                )
                            ),
                            React.createElement('div', { className: 'modal-footer' },
                                React.createElement('button', {
                                    className: 'btn btn-secondary',
                                    onClick: () => setShowEquipmentDialog(false)
                                }, 'Cancel')
                            )
                        )
                    )
                ),

                drawnEquipment && React.createElement('div', {
                    className: 'modal show d-block',
                    style: { backgroundColor: 'rgba(0,0,0,0.5)' },
                    onClick: () => setDrawnEquipment(null)
                },
                    React.createElement('div', {
                        className: 'modal-dialog modal-dialog-centered',
                        onClick: (e) => e.stopPropagation()
                    },
                        React.createElement('div', { className: 'modal-content' },
                            React.createElement('div', { className: 'modal-header' },
                                React.createElement('h5', { className: 'modal-title' }, 'üîß Equipment Drawn'),
                                React.createElement('button', {
                                    type: 'button',
                                    className: 'btn-close',
                                    onClick: () => setDrawnEquipment(null)
                                })
                            ),
                            React.createElement('div', { className: 'modal-body text-center' },
                                React.createElement('p', null, 'You drew:'),
                                React.createElement('div', { className: 'd-flex justify-content-center' },
                                    React.createElement('div', { className: 'game-card card-equipment' },
                                        React.createElement('div', { className: 'card-body' },
                                            drawnEquipment.emoji && React.createElement('div', { className: 'card-emoji' }, drawnEquipment.emoji),
                                            React.createElement('div', { className: 'card-type' }, 'equipment'),
                                            React.createElement('div', { className: 'card-name' }, drawnEquipment.name),
                                            drawnEquipment.description && React.createElement('div', { className: 'card-description' }, drawnEquipment.description),
                                            drawnEquipment.duration && React.createElement('div', { className: 'card-description' }, drawnEquipment.duration)
                                        )
                                    )
                                )
                            ),
                            React.createElement('div', { className: 'modal-footer' },
                                React.createElement('button', {
                                    className: 'btn btn-primary',
                                    onClick: () => setDrawnEquipment(null)
                                }, 'OK')
                            )
                        )
                    )
                ),

                drawnPleasure && React.createElement('div', {
                    className: 'modal show d-block',
                    style: { backgroundColor: 'rgba(0,0,0,0.5)' },
                    onClick: () => setDrawnPleasure(null)
                },
                    React.createElement('div', {
                        className: 'modal-dialog modal-dialog-centered',
                        onClick: (e) => e.stopPropagation()
                    },
                        React.createElement('div', { className: 'modal-content' },
                            React.createElement('div', { className: 'modal-header' },
                                React.createElement('h5', { className: 'modal-title' }, 'üíù Pleasure Card Drawn'),
                                React.createElement('button', {
                                    type: 'button',
                                    className: 'btn-close',
                                    onClick: () => setDrawnPleasure(null)
                                })
                            ),
                            React.createElement('div', { className: 'modal-body text-center' },
                                React.createElement('p', null, 'You drew:'),
                                React.createElement('div', { className: 'd-flex justify-content-center' },
                                    React.createElement('div', { className: 'game-card card-pleasure' },
                                        React.createElement('div', { className: 'card-body' },
                                            drawnPleasure.emoji && React.createElement('div', { className: 'card-emoji' }, drawnPleasure.emoji),
                                            React.createElement('div', { className: 'card-type' }, 'pleasure'),
                                            React.createElement('div', { className: 'card-name' }, drawnPleasure.name),
                                            drawnPleasure.description && React.createElement('div', { className: 'card-description' }, drawnPleasure.description),
                                            drawnPleasure.duration && React.createElement('div', { className: 'card-description' }, drawnPleasure.duration)
                                        )
                                    )
                                )
                            ),
                            React.createElement('div', { className: 'modal-footer' },
                                React.createElement('button', {
                                    className: 'btn btn-primary',
                                    onClick: () => setDrawnPleasure(null)
                                }, 'OK')
                            )
                        )
                    )
                ),

                connected && gameState && React.createElement('div', { className: 'alert alert-warning mt-4' },
                    React.createElement('div', { className: 'fs-5 fw-bold mb-3', style: { color: 'white' } },
                        `üî• Spanking Queue (${gameState?.queue?.length || 0}/5)`
                    ),
                    (!gameState?.queue || gameState.queue.length === 0) && React.createElement('div', {
                        className: 'fst-italic',
                        style: { color: 'rgba(255, 255, 255, 0.8)' }
                    }, 'No punishments queued yet'),
                    React.createElement('div', { className: 'vstack gap-2' },
                        (gameState?.queue || []).map((item, idx) =>
                            React.createElement('div', { className: 'card border-warning', key: idx },
                                React.createElement('div', { className: 'card-body p-3' },
                                React.createElement('div', { className: 'd-flex gap-2 flex-wrap mb-2 justify-content-between align-items-center' },
                                    React.createElement('div', { className: 'd-flex gap-2 flex-wrap' },
                                        React.createElement('div', { className: 'text-center' },
                                            React.createElement('span', { className: 'badge bg-primary d-block mb-1' }, item.position.name),
                                            React.createElement('div', { style: { fontSize: '1.5rem' } }, item.position.emoji || 'üìç')
                                        ),
                                        React.createElement('div', { className: 'text-center' },
                                            React.createElement('span', { className: 'badge bg-danger d-block mb-1' }, item.intensity.name),
                                            React.createElement('div', { style: { fontSize: '1.5rem' } }, item.intensity.emoji || 'üí™')
                                        ),
                                        React.createElement('div', { className: 'text-center' },
                                            React.createElement('span', { className: 'badge bg-success d-block mb-1' }, item.time.name),
                                            React.createElement('div', { style: { fontSize: '1.5rem' } }, item.time.emoji || '‚è±Ô∏è')
                                        )
                                    ),
                                    React.createElement('button', {
                                        className: 'btn btn-sm btn-primary',
                                        onClick: () => startCountdown(item, 'punishment')
                                    }, '‚è±Ô∏è Start Timer')
                                ),
                                item.equipment && item.equipment.length > 0 &&
                                React.createElement('div', { className: 'd-flex gap-2 flex-wrap pt-2 border-top' },
                                    item.equipment.map((eq, eqIdx) =>
                                        React.createElement('span', { className: 'badge bg-danger-subtle text-danger-emphasis', key: eqIdx },
                                            eq.emoji ? `${eq.emoji} ${eq.name}` : eq.name
                                        )
                                    )
                                )
                            )
                            )
                        )
                    )
                ),

                connected && gameState && (isPlayer1 ? gameState?.player2?.pleasureCards?.length > 0 : myStats?.pleasureCards?.length > 0) && React.createElement('div', { className: 'card' },
                    React.createElement('div', { className: 'card-header' },
                        React.createElement('h5', { className: 'mb-0' }, isPlayer1 ? 'üíù Player 2 Pleasure Cards' : 'üíù Your Pleasure Cards')
                    ),
                    React.createElement('div', { className: 'card-body' },
                        React.createElement('div', { className: 'd-flex gap-3 flex-wrap' },
                            (isPlayer1 ? gameState.player2.pleasureCards : myStats.pleasureCards).map((card, idx) =>
                                React.createElement('div', { key: idx, className: 'position-relative' },
                                    React.createElement('div', {
                                        className: 'game-card card-pleasure',
                                        style: { marginBottom: '2.5rem' }
                                    },
                                        React.createElement('div', { className: 'card-body' },
                                            card.emoji && React.createElement('div', { className: 'card-emoji' }, card.emoji),
                                            React.createElement('div', { className: 'card-type' }, 'pleasure'),
                                            React.createElement('div', { className: 'card-name' }, card.name),
                                            card.description && React.createElement('div', { className: 'card-description' }, card.description),
                                            card.duration && React.createElement('div', { className: 'card-description' }, card.duration)
                                        )
                                    ),
                                    card.duration && card.duration !== 'null' && React.createElement('button', {
                                        className: 'btn btn-sm btn-primary position-absolute',
                                        style: { bottom: '-2rem', left: '50%', transform: 'translateX(-50%)', whiteSpace: 'nowrap' },
                                        onClick: () => startCountdown(card, 'pleasure')
                                    }, '‚è±Ô∏è Start Timer')
                                )
                            )
                        )
                    )
                ),

                React.createElement('div', { className: 'card mb-3 mt-4' },
                    React.createElement('div', {
                        className: 'card-header bg-light d-flex justify-content-between align-items-center',
                        style: { cursor: 'pointer' },
                        onClick: () => setLogsCollapsed(!logsCollapsed)
                    },
                        React.createElement('strong', null,
                            status === 'waiting' ? 'üìã Activity Log - ‚è≥ Waiting for Player 2...' :
                            status === 'connecting' ? 'üìã Activity Log - üîÑ Connecting...' :
                            status === 'connected' ? 'üìã Activity Log - ‚úÖ Connected!' :
                            'üìã Activity Log - üîß Initializing...'
                        ),
                        React.createElement('span', { className: 'badge bg-secondary' }, logsCollapsed ? '‚ñº Show' : '‚ñ≤ Hide')
                    ),
                    !logsCollapsed && React.createElement('div', { className: 'card-body p-0' },
                        React.createElement('div', { className: 'log-container p-3' },
                            logs.length === 0 ?
                                React.createElement('div', { className: 'text-muted fst-italic small' }, 'No activity yet') :
                                logs.map((log, i) =>
                                    React.createElement('div', { className: 'border-start border-primary border-3 bg-light rounded p-2 mb-1 small', key: i },
                                        React.createElement('span', { className: 'text-muted me-2 small' }, log.time),
                                        React.createElement('span', null, log.message)
                                    )
                                )
                        )
                    )
                ),

                // Countdown Modal
                countdownActive && React.createElement('div', { className: 'countdown-modal-overlay' },
                    React.createElement('div', { className: 'countdown-container' },
                        React.createElement('div', { className: 'countdown-title' },
                            countdownType === 'punishment' ? 'üî• Punishment Timer' : 'üíù Pleasure Timer'
                        ),
                        countdownCard && React.createElement('div', { className: 'countdown-card' },
                            countdownType === 'punishment' && React.createElement('div', null,
                                React.createElement('div', { className: 'd-flex gap-3 justify-content-center mb-3' },
                                    React.createElement('div', { className: 'text-center' },
                                        React.createElement('div', { style: { fontSize: '2rem' } }, countdownCard.position?.emoji || 'üìç'),
                                        React.createElement('div', { className: 'small text-white' }, countdownCard.position?.name || '')
                                    ),
                                    React.createElement('div', { className: 'text-center' },
                                        React.createElement('div', { style: { fontSize: '2rem' } }, countdownCard.intensity?.emoji || 'üí™'),
                                        React.createElement('div', { className: 'small text-white' }, countdownCard.intensity?.name || '')
                                    ),
                                    React.createElement('div', { className: 'text-center' },
                                        React.createElement('div', { style: { fontSize: '2rem' } }, countdownCard.time?.emoji || '‚è±Ô∏è'),
                                        React.createElement('div', { className: 'small text-white' }, countdownCard.time?.name || '')
                                    )
                                ),
                                countdownCard.equipment && countdownCard.equipment.length > 0 && React.createElement('div', { className: 'd-flex gap-2 flex-wrap justify-content-center' },
                                    countdownCard.equipment.map((eq, idx) =>
                                        React.createElement('span', { key: idx, className: 'badge bg-danger' },
                                            eq.emoji ? `${eq.emoji} ${eq.name}` : eq.name
                                        )
                                    )
                                )
                            ),
                            countdownType === 'pleasure' && React.createElement('div', { className: 'text-center' },
                                React.createElement('div', { style: { fontSize: '3rem', marginBottom: '1rem' } }, countdownCard.emoji || 'üíù'),
                                React.createElement('div', { style: { fontSize: '1.5rem', color: 'white', fontWeight: 'bold' } }, countdownCard.name),
                                countdownCard.description && React.createElement('div', { className: 'text-muted mt-2' }, countdownCard.description)
                            )
                        ),
                        React.createElement('div', { className: 'countdown-time' },
                            `${Math.floor(timeRemaining / 60)}:${String(timeRemaining % 60).padStart(2, '0')}`
                        ),
                        React.createElement('div', { className: 'countdown-buttons' },
                            React.createElement('button', {
                                className: 'btn btn-danger btn-lg',
                                onClick: stopCountdown
                            }, '‚è≠Ô∏è Skip')
                        )
                    )
                )
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(App));
    </script>
</body>
</html>
